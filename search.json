[
  {
    "objectID": "mrfahlevi/index.html",
    "href": "mrfahlevi/index.html",
    "title": "Muhammad Reza Fahlevi",
    "section": "",
    "text": "https://orcid.org/0009-0007-6787-6479\n                \n                ‚úâÔ∏è muhammadrezafahlevi666@gmail.com\n            \n        \n    \n    \n        \n            \n            Email Me\n        \n        \n            \n            Facebook\n        \n        \n            \n            Instagram\n        \n        \n            \n            Linkedin\n        \n        \n            \n            Github\n        \n        \n            \n            Twitter\n        \n        \n            \n            Resume"
  },
  {
    "objectID": "mrfahlevi/index.html#selamat-datang-pembaca-yang-terhormat",
    "href": "mrfahlevi/index.html#selamat-datang-pembaca-yang-terhormat",
    "title": "Muhammad Reza Fahlevi",
    "section": "Selamat Datang Pembaca Yang Terhormat",
    "text": "Selamat Datang Pembaca Yang Terhormat\nSaya M.R. Fahlevi,\n\nSpesialis di metode Heuristik dan Metaheuristik\nüíª Hobi: Selain membaca, menulis, dan riset, saya suka mengkomputasi sesuatu secara manual. Contohnya, mengkomputasi pembangkit bilangan acak semu, algoritma numerik, statistika, dan algoritma genetika."
  },
  {
    "objectID": "mrfahlevi/index.html#pendidikan",
    "href": "mrfahlevi/index.html#pendidikan",
    "title": "Muhammad Reza Fahlevi",
    "section": " Pendidikan",
    "text": "Pendidikan\n\n\n    \n        \n        \n            Departemen Ilmu Komputer, Fakultas Ilmu Komputer dan Teknologi Informasi, Universitas Sumatera Utara\n        \n    \n\n\n\nUniversitas Sumatera Utara (Kota Medan, Sumatera Utara, Indonesia) Agustus \\(2018 - 2022\\)\n\nSarjana Ilmu Komputer - S.Kom. (Bachelor of Computer Science)\n\nIPK (GPA): 3,56/4,00 (3.56/4.00)\nKelas Favorit: Metode Heuristik | Desain & Analisis Algoritma | Kecerdasan Buatan & Sistem Cerdas | Probabilitas & Statistika | Analisis Numerik | Pengolahan Citra | Teknik Pemodelan & Simulasi | Kalkulus | Matematika Diskrit | Teori dan Bahasa Automata"
  },
  {
    "objectID": "mrfahlevi/index.html#riset",
    "href": "mrfahlevi/index.html#riset",
    "title": "Muhammad Reza Fahlevi",
    "section": " Riset",
    "text": "Riset\n\n\nSkripsi:\nMencari Nilai Statistik \\(z,t,\\textit{Chi Square},\\) dan \\(f\\) secara Heuristik Berdasarkan Dynamic Significance Level.\nTerbit:\n\nFahlevi, M.R. & Budiman, M.A.¬†(2021). ‚ÄòComputing the Value of Pi in the Manner of Lambda Function with R Statistical Programming Language‚Äô, Data Science: Journal of Computing and Applied Informatics, 5(1), 39-48. Available: https://doi.org/10.32734/jocai.v5.i1-5556\n\nTerbitan Non Peer Reviewed:\n\nFahlevi, M.R. (2024) ‚ÄòLimav: Computation of Matrix and Vectors in Linear Algebra‚Äô. Available at: https://www.fahlevisia.com/paper/2024/fsr2/\nFahlevi, M.R. (2024) ‚ÄòLinav: Computation of Vectors in Linear Algebra‚Äô. Available at: https://www.fahlevisia.com/paper/2024/fsr1/"
  },
  {
    "objectID": "mrfahlevi/index.html#pengalaman-kerja",
    "href": "mrfahlevi/index.html#pengalaman-kerja",
    "title": "Muhammad Reza Fahlevi",
    "section": " Pengalaman Kerja",
    "text": "Pengalaman Kerja\n\n\n\nBadan Pusat Statistik Kab. Kampar \\(-\\) Praktik Kerja Lapangan (PKL) sebagai pengembang perangkat lunak. Membangun perangkat lunak untuk program Desa Cinta Statistik, Desa Laboy Jaya menggunakan teknologi R Shiny framework (Jul - Aug \\(2021\\))"
  },
  {
    "objectID": "mrfahlevi/index.html#projek",
    "href": "mrfahlevi/index.html#projek",
    "title": "Muhammad Reza Fahlevi",
    "section": " Projek",
    "text": "Projek\n\n\n\n Pengolahan Citra menggunakan R Shiny  : Aplikasi pengolahan citra R Shiny dengan fitur bluring, filter RGB, filter median, 3 jenis gangguan pada citra, konvolusi kernel 3x3, dan deteksi tepi.\n RCGA : Algoritma genetika kode-rill untuk menyelesaikan permasalahan optimisasi parameter-rill untuk fungsi di 3-dimensi, implementasi menggunakan bahasa pemrograman R dan Python.\n ilkom : Paket R untuk menemukan nilai kritis statistik \\(z,t,\\textit{Chi Square},\\) dan \\(f\\) dengan tingkat signifkansi dinamik menggunakan prosedur heuristik berdasarkan pencarian biner, metode bagi dua, dan pencarian tabu.\nVNS: Minimisasi penjumlahan eror kuadrat pada model regresi linear ganda menggunakan Variable Neighborhood Search untuk permasalahan optimisasi kontinu.\nTSP: Aproksimasi Travelling Salesman Problem menggunakan Algoritma Simulated Annealing dan Tabu Search."
  },
  {
    "objectID": "mrfahlevi/index.html#keterampilan",
    "href": "mrfahlevi/index.html#keterampilan",
    "title": "Muhammad Reza Fahlevi",
    "section": " Keterampilan",
    "text": "Keterampilan\n\n\n\n\n\n\n\n\n\n\n\nTeknologi Web :\n\n\n\n\n\n\nBootstrap\n\nCSS\n\nJavascript\n\nHTML5\n\n\n\nGit\n\nGitHub\n\nBash\n\nXAMPP\n\n\n\nMySQL\n\nShiny\n\n\n\n\n Komputasi :\n\n\n\n\n\n\nC++\n\nR\n\nPython\n\nJava\n\n\n\nJulia\n\nOctave\n\nRcpp\n\nOpenCV\n\n\n Menulis :\n\n\n\n\n\n\n\\(\\LaTeX\\)\n\nTeXstudio\n\nLyX\n\nRStudio\n\n\n Sistem Operasi :\n\n\n\n\n\n\nFedora Linux\n\nWindows 10"
  },
  {
    "objectID": "mrfahlevi/index.html#statistik-github",
    "href": "mrfahlevi/index.html#statistik-github",
    "title": "Muhammad Reza Fahlevi",
    "section": " Statistik GitHub",
    "text": "Statistik GitHub"
  },
  {
    "objectID": "mrfahlevi/index.html#keterampilan-teknis",
    "href": "mrfahlevi/index.html#keterampilan-teknis",
    "title": "Muhammad Reza Fahlevi",
    "section": "Keterampilan Teknis",
    "text": "Keterampilan Teknis\n\n\n\nBahasa Pemrograman: R | Python | Julia | C++ | Rcpp | LaTeX | MySQL | Javascript | HTML | CSS | Bootstrap | Java\nAlat & Perangkat Lunak: RStudio | Visual Studio Code | Lyx High Level Latex Frontend | VIM | R Shiny | dplyr | ggplot2 | plotly | pandas | Jupyter Lab\nTertarik di bidang: (Meta) Heuristics Method | Probability & Statistics | Data Analysis | Design & Analysis Algorithm | Pattern Recognition & Machine Learning | Deep Neural Evolution\nPenghargaan: Participant in Province Science Olympiad for Chemistry, year 2017 | Participant in Province English Debate Competition, year 2017"
  },
  {
    "objectID": "yth/2024/IntervensiStunting/index.html",
    "href": "yth/2024/IntervensiStunting/index.html",
    "title": "Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok",
    "section": "",
    "text": "Hak Cipta\n        \n            Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok oleh Yulisa Siregar berlisensi di bawah lisensi Attribution-NonCommercial-ShareAlike 4.0 International (Attribusi-NonKomersial-BerbagiSerupa)\n        \n    \n    \n        \n            Kutip Artikel Ini\n            Harvard\n            \n                Siregar, Yulisa. (2024) 'Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok'. Tersedia: https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/ (Accessed: ).\n            \n            APA\n            \n                Siregar, Yulisa. (2024, January 29) Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok. Fahlevisia. Diakses , dari https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/\n            \n            Chicago\n            \n                Siregar, Yulisa. \"Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok\" Diakses . https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/\n            \n            IEEE\n            \n                Y. Siregar. \"kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok\" Fahlevisia, Jan. 29, 2024. Diakses: . [Online]. Tersedia: https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/\n            \n            MHRA\n            \n                Siregar, Yulisa, Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok (2024) &lt;https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/&gt; [diakses ]\n            \n            MLA\n            \n                Yulisa Siregar. \"Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok\". Fahlevisia, 29 January 2024, https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/\n            \n            OSCOLA\n            \n                Yulisa Siregar, 'Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok' (Fahlevisia, 29 January 2024) &lt;https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/&gt; diakses .\n            \n            Vancouver\n            \n                Siregar Y. Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok [Internet]. 2024 [dikutip ]. Tersedia di: https://www.fahlevisia.com/post_artikelYth/IntervensiStunting/\n            \n        \n    \n\n\n\n\n\n\nPemberian bantuan dari TPG UPT Puskesmas Kuok di Desa Lereng, Kec. Kuok. 24 Januari 2024\n\n\n\nStunting merupakan suatu masalah gizi kronis yang disebabkan oleh beberapa faktor, yang mana, faktor terbesarnya ialah nutrisi dan hormon pertumbuhan yang kurang. Stunting merupakan masalah kesehatan yang harus ditangani secara serius. Hal ini berdasarkan hasil olah data yang dilakukan oleh Riset Kesehatan Dasar (Riskesdas), yang menemukan bahwa angka stunting yang melambung cukup tinggi, yaitu 36.8% pada tahun 2007, dan pada tahun 2013 mencapai 37.2% dari 33 provinsi di Indonesia. Secara global, angka ini menunjukkan bahwa Indonesia masih memiliki kasus kekurangan gizi\\(\\textemdash\\)terutama masalah stunting\\(\\textemdash\\)yang tidak sedikit. Karena, World Health Organization (WHO) menetapkan, bahwa, suatu kasus kekurangan gizi pada suatu negara termasuk ke dalam kategori rendah apabila persentasi kasus tersebut di bawah 20%.\n\\(\\qquad\\)Dengan jumlah angka anak stunting yang tidak sedikit, Tim Percepatan Penurunan Stunting (TPPS) bersama dengan Tim Pelaksana Gizi (TPS) Unit Pelayanan Terpadu Pusat Kesehatan Masyarakat Kuok (UPT. Puskesmas Kuok) melaksanakan kegiatan intervensi jumlah anak stunting. Perlu diketahui bahwa terdapat 9 desa yang merupakan cakupan wilayah kerja UPT Puskesmas Kuok, yaitu:\n\n\nDesa Kuok\nDesa Merangin\nDesa Empat Balay\nDesa Pulau Jambu\nDesa Pulau Terap\nDesa Lereng\nDesa Silam\nDesa Batu Langka Kecil\nDesa Bukit Melintang\n\n\nKegiatan intervensi terdiri atas 2 tahap utama, yaitu tahap validasi dan tahap pemberian bantuan. Validasi dilakukan pada tanggal 4 Januari 2024. Pada tahap ini, TPPS dan TPG UPT. Puskesmas Kuok turun ke wilayah kerja, mengunjungi rumah ke rumah warga desa dan memvalidasi keluarga yang mana anaknya teridentifikasi dan/atau berpotensi stunting. Tahap validasi ini berguna untuk keefektifan tahap pemberian bantuan. Berikut merupakan video tahap validasi\n\n\n\nTahap pemberian bantuan dilakukan pada tanggal 24 Januari 2024. Pada tahap ini, rumah-rumah warga desa yang sudah divalidasi diberikan bantuan berupa:\n\n\n6 kotak susu\n3 papan telur\n5 Kg beras\n2 botol vitamin\n\n\nKeluarga yang sudah divalidasi dan diberikan bantuan akan diperhatikan bagaimana pertumbuhan gizi anak mereka. Berikut merupakan video tahap pemberian bantuan.\n\n\n\n\\(\\qquad\\)Kegiatan intervensi jumlah anak stunting ini hingga sekarang masih digencarkan oleh TPG dan TPPS. Kegiatan intervensi ini merupakan bentuk usaha nyata oleh TPPS bersama TPG UPT. Puskesmas Kuok dalam mengurangi jumlah angka anak stunting di Indonesia, khususnya di wilayah kerja UPT. Puskesmas Kuok."
  },
  {
    "objectID": "blog/2024/fsb2/index.html",
    "href": "blog/2024/fsb2/index.html",
    "title": "Google Mengucapkan Selamat atas Pencapaian Fahlevisia",
    "section": "",
    "text": "Email\n        muhammadrezafahlevi666@gmail.com\n    \n\n\n\n\n\n\ngsi_achievement\n\n\nPada tanggal 20 Februari 2024, Google mengucapkan selamat (congratulations) atas pencapaian Fahlevisia yang telah memperoleh klik sebanyak 15 kali melalui pencarian Google. Maka dari itu, Fahlevisia mengucapkan terima kasih kepada Google atas apresiasinya, dan Fahlevisia juga mengucapkan terima kasih kepada para pembaca yang terhormat yang telah mencari dan mengklik situs web Fahlevisia dengan kata kunci Fahlevisia melalui pencarian Google.\nTentu hal ini merupakan penyemangat bagi Fahlevisia untuk tekun berikhtiar sebagai situs web yang menyebarluaskan ilmu komputer, ilmu yang bermanfaat, dan menjadi situs web yang berkah bagi bangsa Indonesia. Fahlevisia juga berusaha sebaik mungkin untuk menciptakan tulisan yang pantas dan tepercaya untuk dijadikan sebagai sumber informasi dan/atau sitasi pembaca yang terhormat.\nUcapan selamat oleh Google ini bukan hanya sebagai apresiasi Google kepada Fahlevisia, tetapi juga sebagai bukti bahwa situs web Fahlevisia terindeks pencarian Google. Dan juga sebagai bukti, bahwa teknologi web semantik (semantic web) yang Fahlevisia gunakan bekerja dengan baik. Dengan menggunakan teknologi web semantik ini, Fahlevisia lebih terlihat dan mudah untuk dijumpai di internet melalui mesin pencarian daring, terutama mesin pencarian Google.\nDengan demikian, penulis sangat bersyukur kepada Allah SWT yang telah melimpahkan rahmat dan karunianya kepada penulis. Sehingga, apa yang diusahakan penulis melalui Fahlevisia berjalan dengan baik, menjadi berkah, dan bermanfaat bagi umat.\n\n    $\\blacksquare$\n\n\n    \n    Hak Cipta\n    Google Mengucapkan Selamat atas Pencapaian Fahlevisia oleh Muhammad Reza Fahlevi berlisensi  Attribution-NonCommercial-ShareAlike 4.0 International (Attribusi-NonKomersial-BerbagiSerupa 4.0 Internasional)\n    Dukung Fahlevisia\n\n\n    \n    Fahlevisia\n    Repositori Digital Personal\n    Do you like what you have read?You may treat the author a cup of coffee as a form of thank you\n    \n         Treate the author a cup of coffee\n    \n    Fahlevisia is thanked to the honourable reader who support us and/or dedicate some of his/her time reading our article."
  },
  {
    "objectID": "paper/2024/fsr2/index.html",
    "href": "paper/2024/fsr2/index.html",
    "title": "Limav: Computation of Vectors and Matrix in Linear Algebra",
    "section": "",
    "text": "Email\n        muhammadrezafahlevi666@gmail.com"
  },
  {
    "objectID": "paper/2024/fsr2/index.html#unary-and-binary-operator-on-matrix",
    "href": "paper/2024/fsr2/index.html#unary-and-binary-operator-on-matrix",
    "title": "Limav: Computation of Vectors and Matrix in Linear Algebra",
    "section": "2.1 Unary and Binary Operator on Matrix",
    "text": "2.1 Unary and Binary Operator on Matrix\n\nFor the unary operators on matrix, we only consider the transpose and the trace for a matrix. For the binary operators on matrix, we have addition, substraction, multiplication by a real numbers, and multiplication of a matrix.\n\n\nDefinition 3 (matrix transpose) Let \\(A=\\left(a_{ij}\\right)\\) and \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\), then transpose of a matrix is a map\n\\[\nt(\\cdot)\\colon  \\mathscr{M}_{m\\times n}(\\mathbb{R})\\to\\mathscr{M}_{n\\times m}(\\mathbb{R})\n\\] \\[\n\\text{s.t. }    A\\mapsto t(A)\\coloneqq(a_{ji})\n\\tag{5}\\]\nRemark 2. The common notation for a transpose of a matrix \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) is \\(A^{\\top}\\in\\mathscr{M}_{n\\times m}(\\mathbb{R})\\) so that \\(\\left(a_{ij}\\right)^{\\top}=\\left(a_{ji}\\right)\\)\n\n\nExample 1 If \\(A\\in\\mathscr{M}_{2\\times3}(\\mathbb{R})\\) such that\n\\[\nA=\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{array}\\right)\n\\]\nthen\n\\[\nA^{\\top}    =\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{array}\\right)^{\\top}\n    =\\left(\\begin{array}{cc}\na_{11} & a_{21}\\\\\na_{12} & a_{22}\\\\\na_{13} & a_{23}\n\\end{array}\\right)\n\\]\nthereby, we have that \\(A^{\\top}\\in\\mathscr{M}_{3\\times2}(\\mathbb{R})\\).\n\n\nDefinition 4 (trace of matrix) Let \\(A=\\left(a_{ij}\\right)\\), then the trace of a matrix is a function \\(\\text{tr}(\\cdot)\\colon\\mathscr{M}_{m\\times n}(\\mathbb{R})\\to\\mathbb{R}\\) s.t.\n\\[\nA\\mapsto\\text{tr}(A)\\coloneqq\\sum_{i=1}^{t}a_{ii}\n\\tag{6}\\]\nwhere \\(t=\\min(m,n)\\).\nRemark 3. Due to numerical issue, we compute the \\(\\text{tr}(A)\\) by using the Kahan‚Äôs sum algorithm.\n\n\nExample 2 Suppose that \\(A\\in\\mathscr{M}_{3}(\\mathbb{R})\\) s.t.\n\\[\nA=\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\\\\\na_{31} & a_{32} & a_{33}\n\\end{array}\\right)\n\\]\nthen\n\\[\n\\begin{align}\n\\text{tr}(A)&\\coloneqq\\sum_{i=1}^{3}a_{ii}\\\\\n\\text{tr}(A)&=a_{11}+a_{22}+a_{33}\n\\end{align}\n\\]\n\n\nDefinition 5 (matrix addition) Let \\(A,B,C\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) where \\(A=\\left(a_{ij}\\right)\\) and \\(B=\\left(b_{ij}\\right)\\), then the addition of 2 matrix is a map \\(+\\colon\\mathscr{M}_{m\\times n}(\\mathbb{R})\\times\\mathscr{M}_{m\\times n}(\\mathbb{R})\\to\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) s.t.\n\\[\n(A,B)\\mapsto C\\coloneqq A+B\n\\tag{7}\\]\nwhere \\(C=\\left(c_{ij}\\right)\\) and \\(c_{ij}=a_{ij}+b_{ij}\\).\n\n\nDefinition 6 (matrix substraction) Let \\(A,B,C\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) where \\(A=\\left(a_{ij}\\right)\\) and \\(B=\\left(b_{ij}\\right)\\), then the substraction of 2 matrix is a map \\(-\\colon\\mathscr{M}_{m\\times n}(\\mathbb{R})\\times\\mathscr{M}_{m\\times n}(\\mathbb{R})\\to\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) s.t.\n\\[\n(A,B)\\mapsto C\\coloneqq A-B\n\\tag{8}\\]\nwhere \\(C=\\left(c_{ij}\\right)\\) and \\(c_{ij}=a_{ij}-b_{ij}\\).\n\n\nDefinition 7 (scaled matrix) Let \\(\\lambda\\in\\mathbb{R}\\) and \\(A,B\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\). If \\(A=\\left(a_{ij}\\right)\\), then such a matrix can be scaled by \\(\\lambda\\) by using the following maps, \\(\\cdot\\colon\\mathbb{R}\\times\\mathscr{M}_{m\\times n}(\\mathbb{R})\\to\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) s.t.\n\\[\n(\\lambda,A)\\mapsto B\\coloneqq\\lambda A\n\\tag{9}\\]\nwhere \\(B=\\left(b_{ij}\\right)\\) and \\(b_{ij}=\\lambda a_{ij}\\)\n\n\nExample 3 Let \\(\\lambda\\in\\mathbb{R}\\) and \\(A,B,C\\in\\mathscr{M}_{2\\times3}(\\mathbb{R})\\). If\n\\[\nA=\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{array}\\right)\\text{ and }B=\\left(\\begin{array}{ccc}\nb_{11} & b_{12} & b_{13}\\\\\nb_{21} & b_{22} & b_{23}\n\\end{array}\\right)\n\\]\nthen\n\\((i)\\) If \\(C=A+B\\), then\n\\[\n\\begin{align}\nC   &=\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{array}\\right)+\\left(\\begin{array}{ccc}\nb_{11} & b_{12} & b_{13}\\\\\nb_{21} & b_{22} & b_{23}\n\\end{array}\\right) \\\\\nC   &=\\left(\\begin{array}{ccc}\na_{11}+b_{11} & a_{12}+b_{12} & a_{13}+b_{13}\\\\\na_{21}+b_{21} & a_{22}+b_{22} & a_{23}+b_{23}\n\\end{array}\\right)\n\\end{align}\n\\]\n\\((ii)\\) If \\(C=A-B\\), then\n\\[\n\\begin{align}\nC   &=\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{array}\\right)-\\left(\\begin{array}{ccc}\nb_{11} & b_{12} & b_{13}\\\\\nb_{21} & b_{22} & b_{23}\n\\end{array}\\right) \\\\\nC   &=\\left(\\begin{array}{ccc}\na_{11}-b_{11} & a_{12}-b_{12} & a_{13}-b_{13}\\\\\na_{21}-b_{21} & a_{22}-b_{22} & a_{23}-b_{23}\n\\end{array}\\right)\n\\end{align}\n\\]\n\\((iii)\\) If \\(C=\\lambda A\\), then\n\\[\n\\begin{align}\nC   &=\\lambda\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{array}\\right) \\\\\nC   &=\\left(\\begin{array}{ccc}\n\\lambda a_{11} & \\lambda a_{12} & \\lambda a_{13}\\\\\n\\lambda a_{21} & \\lambda a_{22} & \\lambda a_{23}\n\\end{array}\\right)\n\\end{align}\n\\]\n\n\nDefinition 8 (multiplication of matrix and vector) Suppose that \\((\\mathbb{R}^{n},+,\\cdot)\\) and \\((\\mathbb{R}^{m},+,\\cdot)\\) are 2 vector spaces, let \\(\\vec{x}\\in\\mathbb{R}^{n}\\) and \\(\\vec{y}\\in\\mathbb{R}^{m}\\), then the multiplication of matrix and vector is defined through function \\(\\cdot\\colon\\mathscr{M}_{m\\times n}(\\mathbb{R})\\times\\mathbb{R}^{n}\\to\\mathbb{R}^{m}\\) s.t.\n\\[\n(A,\\vec{x})\\mapsto\\vec{y}\\coloneqq A\\vec{x}\n\\tag{10}\\]\nSuppose that \\(A=\\left(a_{ij}\\right)\\) and \\(\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})\\), if \\(A\\vec{x}=\\vec{y}\\) then \\(\\vec{y}=(y_{1},y_{2},\\ldots,y_{m})\\) s.t.\n\\[\ny_{i}=\\sum_{j=1}^{n}a_{ij}x_{j}\n\\tag{11}\\]\n\n\nDefinition 9 (matrix multiplication) Let \\(A\\in\\mathscr{M}_{m\\times t}(\\mathbb{R}),B\\in\\mathscr{M}_{t\\times n}(\\mathbb{R})\\), and \\(C\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\), if \\(A=\\left(a_{ij}\\right)\\) and \\(B=\\left(b_{ij}\\right)\\), then the multiplication of a matrix is a function \\(\\cdot\\colon\\mathscr{M}_{m\\times t}(\\mathbb{R})\\times\\mathscr{M}_{t\\times n}(\\mathbb{R})\\to\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) s.t.\n\\[\n(A,B)\\mapsto C\\coloneqq AB\n\\tag{12}\\]\nwhere \\(C=\\left(c_{ij}\\right)\\) and\n\\[\nc_{ij}=\\sum_{k=1}^{t}a_{ik}b_{kj}\n\\tag{13}\\]\nRemark 4. Two matrix \\(A\\) and \\(B\\), only can be multiplied if\n\\[\n\\#\\text{col}(A)=\\#\\text{row}(B)\n\\tag{14}\\]\nwhere \\(\\#\\text{col}(A)\\) is the number of column of \\(A\\) matrix and \\(\\#\\text{row}(B)\\) is the number of row of \\(B\\) matrix. If \\(C=AB\\), then \\(\\#\\text{row}(C)=\\#\\text{row}(A)\\) and \\(\\#\\text{col}(C)=\\#\\text{col}(B)\\).\n\n\nDefinition 10 Let \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) s.t. \\(A=\\left(a_{ij}\\right)\\), then the following operator \\(\\textit{row}(i;A)\\) return the elements of \\(A\\) matrix at the \\(i\\)th-row as a vector, i.e.,\n\\[\nA=\\left(a_{ij}\\right)\\mapsto\\textit{row}(i;A)\\coloneqq(a_{i1},a_{i2},\\ldots,a_{in})\n\\tag{15}\\]\nand \\(\\textit{col}(A;j)\\) return the entries of matrix \\(A\\) at the \\(j\\)th-column as a vector, i.e.,\n\\[\nA=\\left(a_{ij}\\right)\\mapsto\\textit{col}(j;A)\\coloneqq(a_{1j},a_{2j},\\ldots,a_{mj})\n\\tag{16}\\]\n\n\n\\(\\quad\\) Theoritically, the computation of 2 matrix is defined in Equation¬†13. Due to numerical issue, we do not compute 2 matrix \\(A\\) and \\(B\\) as it is, instead, we compute it by the virtue of inner product \\(\\langle\\cdot,\\cdot\\rangle\\colon\\mathbb{R}^{n}\\times\\mathbb{R}^{n}\\to\\mathbb{R}\\) s.t. if \\(\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})\\) and \\(\\vec{y}=(y_{1},y_{2},\\ldots,y_{n})\\) then\n\\[\n\\langle\\vec{x},\\vec{y}\\rangle\\coloneqq\\sum_{i=1}^{n}x_{i}y_{i}\n\\tag{17}\\]\nand again, due to numerical issue, we compute the inner product of 2 vectors by using the following equation\n\\[\n\\langle\\vec{x},\\vec{y}\\rangle\\coloneqq\\lambda\\mu\\left\\langle \\frac{1}{\\lambda}\\vec{x},\\frac{1}{\\mu}\\vec{y}\\right\\rangle\n\\tag{18}\\]\nwhere \\(\\lambda,\\mu\\in\\mathbb{R}\\), and with regards to the summation, we compute it by using the Kahan‚Äôs sum algorithm (Solomon, J., 2015). The following passage is description how we compute the multiplication of 2 matrix.\n\n\n\\(\\quad\\) Let \\(A\\in\\mathscr{M}_{m\\times t}(\\mathbb{R}),B\\in\\mathscr{M}_{t\\times n}(\\mathbb{R})\\), and \\(C\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\). If \\(A=\\left(a_{ij}\\right)\\) and \\(B=\\left(b_{ij}\\right)\\), then\n\\[\n(A,B)\\mapsto C\\coloneqq AB\n\\]\nwhere \\(C=\\left(c_{ij}\\right)\\) and \\(c_{ij}\\coloneqq\\langle\\vec{x}_{i},\\vec{y}_{j}\\rangle\\) for \\(\\vec{x}_{i},\\vec{y}_{j}\\in\\mathbb{R}^{t}\\) s.t. \\(\\vec{x}_{i}\\coloneqq\\textit{row}(i;A)\\) and \\(\\vec{y}_{j}\\coloneqq\\textit{col}(j;B)\\). In order to handle the numerical issue, the computation of the inner product is computed by using Equation¬†18 by choosing \\(\\lambda_{i},\\mu_{j}\\in\\mathbb{R}\\) s.t.\n\\[\n\\begin{align}\n\\lambda_{i} &\\coloneqq\\max\\left\\{ \\vert a_{i1}\\vert,\\vert a_{i2}\\vert,\\ldots,\\vert a_{it}\\vert\\bigg|\\vec{x}_{i}=(a_{i1},a_{i2},\\ldots,a_{it})\\right\\} \\\\\n\\mu_{j} &\\coloneqq\\max\\left\\{ \\vert b_{1j}\\vert,\\vert b_{2j}\\vert,\\ldots,\\vert b_{tj}\\vert\\bigg|\\vec{y}_{j}=(b_{1j},b_{2j},\\ldots,b_{tj})\\right\\}\n\\end{align}\n\\]\nin other words, \\(\\lambda_{i}\\) and \\(\\mu_{j}\\) are the maximum of the absolute value of \\(\\vec{x}_{i}\\) and \\(\\vec{y}_{j}\\), respectively. If it is happaned to be \\(\\lambda_{i}=0\\) or \\(\\mu_{j}=0\\), then replace \\(\\lambda_{i}=\\varepsilon\\) or \\(\\mu_{j}=\\varepsilon\\) for \\(0&lt;\\varepsilon\\ll1\\) to avoid division by \\(0\\). The following is algorithm for the computation of 2 matrix\n    \\begin{algorithm}\n    \\caption{Multiplication of 2 matrix}\n    \\begin{algorithmic}\n    \\STATE Define $A\\in\\mathscr{M}_{m\\times t}(\\mathbb{R})$ s.t. $A=\\left(a_{ij}\\right)$\n    \\STATE Define $B\\in\\mathscr{M}_{t\\times n}(\\mathbb{R})$ s.t. $B=\\left(b_{ij}\\right)$\n    \\STATE let $C\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})$ s.t. $C=\\left(c_{ij}\\right)\\qquad$ // We may think $c_{ij}=0$ initially.\n    \\FOR{$i\\longleftarrow 1,2,\\ldots,\\#\\textit{row}(A)$}\n        \\For{$j\\longleftarrow 1,2,\\ldots,\\#\\textit{col}(B)$}\n            \\STATE let $\\vec{x}\\longleftarrow\\textit{row}(i;A)\\qquad$ // $\\vec{x}=(a_{i1},a_{i2},\\ldots,a_{it})$\n            \\STATE let $\\vec{y}\\longleftarrow\\textit{col}(j;B)\\qquad$ // $\\vec{y}=(b_{1j},b_{2j},\\ldots,b_{tj})$\n            \\STATE $c_{ij}\\longleftarrow\\langle\\vec{x},\\vec{y}\\rangle\\qquad$ // the inner product is computed by using Equation¬†18\n        \\ENDFOR\n    \\ENDFOR\n    \\RETURN{$C$}\n    \\end{algorithmic}\n    \\end{algorithm}\n\n\n\nExample 4 Let \\(A,B,C\\in \\mathscr{M}_3(\\mathbb{R})\\). If\n\\[\nA=  \\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\\\\\na_{31} & a_{32} & a_{33}\n\\end{array}\\right)\n\\]\nand\n\\[\nB=\\left(\\begin{array}{ccc}\nb_{11} & b_{12} & b_{13}\\\\\nb_{21} & b_{22} & b_{23}\\\\\nb_{31} & b_{32} & b_{33}\n\\end{array}\\right)\n\\]\nthen the multiplication of \\(C=AB\\) as follows. Let \\(\\vec{x}_{i},\\vec{y}_{i}\\in\\mathbb{R}^{3}\\) s.t. \\(\\vec{x}_{i}\\coloneqq\\textit{row}(i;A)\\) and \\(\\vec{y}_{j}\\coloneqq\\textit{col}(j;B)\\), then we may write \\(A\\) and \\(B\\) matrix as follows\n\\[\nA=\\left(\\begin{array}{ccc}\n\\longleftarrow & \\vec{x}_{1} & \\longrightarrow \\\\\n\\longleftarrow & \\vec{x}_{2} & \\longrightarrow \\\\\n\\longleftarrow & \\vec{x}_{3} & \\longrightarrow\n\\end{array}\\right)\n\\]\nand\n\\[\nB=\\left(\\begin{array}{ccc}\n\\Big\\uparrow & \\Big\\uparrow & \\Big\\uparrow\\\\\n\\vec{y}_{1} & \\vec{y}_{2} & \\vec{y}_{3}\\\\\n\\Big\\downarrow & \\Big\\downarrow & \\Big\\downarrow\n\\end{array}\\right)\n\\]\nthen for \\(C=AB\\) we have that \\(C=\\left(c_{ij}\\right)\\) s.t.\n\\[\nC=\\left(\\begin{array}{ccc}\n\\langle\\vec{x}_{1},\\vec{y}_{1}\\rangle & \\langle\\vec{x}_{1},\\vec{y}_{2}\\rangle & \\langle\\vec{x}_{1},\\vec{y}_{3}\\rangle\\\\\n\\langle\\vec{x}_{2},\\vec{y}_{1}\\rangle & \\langle\\vec{x}_{2},\\vec{y}_{2}\\rangle & \\langle\\vec{x}_{2},\\vec{y}_{3}\\rangle\\\\\n\\langle\\vec{x}_{3},\\vec{y}_{1}\\rangle & \\langle\\vec{x}_{3},\\vec{y}_{2}\\rangle & \\langle\\vec{x}_{3},\\vec{y}_{3}\\rangle\n\\end{array}\\right)\n\\]"
  },
  {
    "objectID": "paper/2024/fsr2/index.html#pseudomatrix",
    "href": "paper/2024/fsr2/index.html#pseudomatrix",
    "title": "Limav: Computation of Vectors and Matrix in Linear Algebra",
    "section": "2.2 Pseudomatrix",
    "text": "2.2 Pseudomatrix\n\nOne of common mistake when study computer science is happened to be when someone want to create/model a \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) by using a programming language. And that mistake is thinking that \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) is an array of an array, or more precisely, \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) is an array of size \\(m\\) where each elements is an array of size \\(n\\).\n\n\n\\(\\quad\\) For example, in C++ programming language, thinking that \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) can be modeled as follows is a mistake\nstd::vector&lt;std::vector&lt;double&gt;&gt; superevil = {{1.0, 2.0},{3.0,4.0}};\ndouble the_evil = superevil.at(0).at(1);\neven though that it works, nevertheless, it‚Äôs not good to do such a things, and there is a good reason for prohibited to do such a things. One of such a reasons for prohibit to thinking \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) is an array of an array is it‚Äôs like to have a 1 box where inside such a box there are \\(m\\) boxes, and for each \\(m\\) boxes there are \\(n\\) items. Of course, if someone is delivering an items to someone else in such a way, then one may think that why don‚Äôt we just have a box that can be filled by \\(mn\\) items. Therefore, in order to handle this ‚Äòevil‚Äô, pseudomatrix is a good data structure to model a \\(m\\times n\\) matrix.\n\\(\\quad\\) Pseudomatrix is a (non primitive) data structure to model \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\). Pseudomatrix is a vector for which such a vector is treated as if it is a matrix. The following is definition of pseudomatrix.\n\n\nDefinition 11 (pseudomatrix) Let \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\), a pseudomatrix is a vector \\(\\vec{x}\\in\\mathbb{R}^{t}\\) where \\(t=mn\\) s.t.\n\\[\nA=\\left(a_{ij}\\right)\\Leftrightarrow\\vec{x}=(a_{11},a_{12},\\ldots,a_{1n},a_{21},a_{22},\\ldots,a_{2n},\\ldots,a_{m1},a_{m2},\\ldots,a_{mn})\n\\tag{19}\\]\nSince pseudomatrix is a vector, then each elements of such a vector only can be indexed by a number, not a pair of numbers. Hence, we need a function \\(f\\colon\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}\\) so that\n\\[\n\\begin{align}\nA=\\left(a_{ij}\\right) &\\Leftrightarrow\\vec{x}=(a_{f(1,1)},a_{f(1,2)},\\ldots,a_{f(1,n)},\\ldots,a_{f(m,1)},a_{f(m,2)},\\ldots,a_{f(m,n)})\\\\\n    &\\Leftrightarrow\\vec{x}=(x_{1},x_{2},\\ldots,x_{t})\n\\end{align}\n\\]\ndue to \\(\\vec{x}\\in\\mathbb{R}^{t}\\) and \\(t=mn\\). Such a function is written in the following theorem\n\n\nTheorem 1 Let \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R}),\\vec{x}\\in\\mathbb{R}^{t}\\), and \\(t=mn\\). If \\(A=\\left(a_{ij}\\right)\\) and its pseudomatrix is a vector \\(\\vec{x}=(x_{1},x_{2},\\ldots,x_{t})\\), then\n\\[\na_{ij}=x_{f(i,j)}\n\\]\nwhere \\(f\\colon\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}\\) s.t.\n\\[\n(i,j)\\mapsto f(i,j)\\coloneqq(i-1)n+j\n\\tag{20}\\]\nfor \\(1\\leq f(i,j)\\leq t\\), \\(i=1,2,\\ldots,m\\), and \\(j=1,2,\\ldots,n\\).\n\n\nProof. Let \\(A\\in\\mathscr{M}_{m\\times n}(\\mathbb{R})\\) and \\(\\vec{x}\\in\\mathbb{R}^{n},t=mn\\). By definition, let the pseudomatrix of \\(A\\) is a vector \\(\\vec{x}\\) s.t.\n\\[\n\\begin{align}\nA=\\left(a_{ij}\\right)   &\\Leftrightarrow\\vec{x}=(a_{11},a_{12},\\ldots,a_{1n},a_{21},a_{22},\\ldots,a_{2n},\\ldots,a_{m1},\\ldots,a_{mn})\\\\\n    &\\Leftrightarrow\\vec{x}=(x_{f(1,1)},x_{f(1,2)},\\ldots,x_{f(1,n)},x_{f(2,1)},\\ldots,x_{f(2,n)},\\ldots,x_{f(m,1)},\\ldots,x_{f(m,n)})\\\\\n    &\\Leftrightarrow\\vec{x}=(x_{1},x_{2},\\ldots,x_{t})\n\\end{align}\n\\tag{21}\\]\nso for \\(a_{ij}\\) in matrix \\(A\\), we have a corresponding element \\(x_{f(i,j)}\\) in \\(\\vec{x}\\) s.t.\n\\[\na_{ij}=x_{f(i,j)}\n\\]\nthe definition of \\(f\\colon\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}\\) s.t. \\((i,j)\\mapsto f(i,j)\\) is defined through induction of every \\(i=1,2,\\ldots,m\\) and \\(j=1,2,\\ldots,n\\) as follows. From Equation¬†21 line one and two, we may rearrange the pseudomatrix as a row and column to form a matrix, hence we have the following equality of a matrix\n\\[\n\\left(\\begin{array}{cccc}\na_{11} & a_{12} & \\cdots & a_{1n}\\\\\na_{21} & a_{22} & \\cdots & a_{2n}\\\\\na_{31} & a_{32} & \\cdots & a_{3n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\na_{m1} & a_{m2} & \\cdots & a_{mn}\n\\end{array}\\right)=\\left(\\begin{array}{cccc}\nx_{f(1,1)} & x_{f(1,2)} & \\cdots & x_{f(1,n)}\\\\\nx_{f(2,1)} & x_{f(2,2)} & \\cdots & x_{f(2,n)}\\\\\nx_{f(3,1)} & x_{f(3,2)} & \\cdots & x_{f(3,n)}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\nx_{f(m,1)} & x_{f(m,2)} & \\cdots & x_{f(m,n)}\n\\end{array}\\right)\n\\]\nsince we are interested in the index of the elements of a matrix, we simplify the notation of the matrix equality above by only look at the subscript, thus\n\\[\n\\left(\\begin{array}{cccc}\n(1,1) & (1,2) & \\cdots & (1,n)\\\\\n(2,1) & (2,2) & \\cdots & (2,n)\\\\\n(3,1) & (3,2) & \\cdots & (3,n)\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n(m,1) & (m,2) & \\cdots & (m,n)\n\\end{array}\\right)=\\left(\\begin{array}{cccc}\nf(1,1) & f(1,2) & \\cdots & f(1,n)\\\\\nf(2,1) & f(2,2) & \\cdots & f(2,n)\\\\\nf(3,1) & f(3,2) & \\cdots & f(3,n)\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\nf(m,1) & f(m,2) & \\cdots & f(m,n)\n\\end{array}\\right)\n\\]\nthrough Equation¬†21 line two and three we have the equation for \\(f(i,j)\\) by rearrange the elements of the pseudomatrix \\(\\vec{x}\\) as a row and column to form a matrix and looking at its subscript, hence we have the following equality of a matrix\n\\[\n\\left(\\begin{array}{cccc}\nf(1,1) & f(1,2) & \\cdots & f(1,n)\\\\\nf(2,1) & f(2,2) & \\cdots & f(2,n)\\\\\nf(3,1) & f(3,2) & \\cdots & f(3,n)\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\nf(m,1) & f(m,2) & \\cdots & f(m,n)\n\\end{array}\\right)=\\left(\\begin{array}{cccc}\n1 & 2 & \\cdots & n\\\\\nn+1 & n+2 & \\cdots & n+n=2n\\\\\n2n+1 & 2n+2 & \\cdots & 2n+n=3n\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n(m-1)n+1 & (m-1)n+2 & \\cdots & (m-1)n+n=mn\n\\end{array}\\right)\n\\]\nif \\(i\\coloneqq m\\) and \\(j\\coloneqq n\\), then from the equality of a matrix above, we see that\n\\[\n\\begin{align}\nf(m,n)  &=(m-1)n+n\\\\\n\\Leftrightarrow f(i,j)  &=(i-1)n+j\n\\end{align}\n\\]\nand \\(1\\leq f(i,j)\\leq t\\) since \\(t=mn\\). Therefore, the pseudomatrix of \\(A\\) is a vector \\(\\vec{x}\\) s.t.\n\\[\nA=\\left(a_{ij}\\right)\\Leftrightarrow\\vec{x}=\\left(\\begin{array}{ccc}\n\\longleftarrow & x_{f(i,j)} & \\longrightarrow\\end{array}\\right)\n\\]\nwhere \\(f\\colon\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}\\) s.t. \\((i,j)\\mapsto f(i,j)\\coloneqq(i-1)n+j\\), for which the following equality\n\\[\na_{ij}=x_{f(i,j)}=x_{(i-1)n+j}\n\\]\nis obtained thereof.\n\n\\(\\square\\)\n\nRemark 5. The equality \\(a_{ij}=x_{f(i,j)}\\) where \\(f\\colon\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}\\) s.t.\n\\[\n(i,j)\\mapsto(i-1)n+j\n\\]\nis true if we start counting from \\(1\\). If we start counting from \\(0\\), i.e., \\(i=0,1,\\ldots,m-1\\) and \\(j=0,1,\\ldots,n-1\\), then we have that if \\(A=(a_{ij})\\) and its pseudomatrix is vector \\(\\vec{x}=(x_{0},x_{1},\\ldots,x_{t})\\) and \\(t=mn-1\\), then\n\\[\na_{ij} = x_{f(i,j)}\n\\]\nwhere \\(f\\colon \\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}\\) s.t.\n\\[\n(i,j)\\mapsto f(i,j)\\coloneqq in+j\n\\tag{22}\\]\nand \\(0\\leq f(i,j)\\leq t\\). In this case, \\(t=mn-1\\) since we start counting from \\(0\\). And the proof is similar to the proof of theorem [thm: idx_pseudomat].\n\n\nExample 5 Let \\(A\\in\\mathscr{M}_{2\\times 3}(\\mathbb{R})\\) s.t.\n\\[\nA=\\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\n\\end{array}\\right)\n\\]\nthen the pseudomatrix of \\(A\\) is a vector \\(\\vec{x}\\in\\mathbb{R}^t\\) for \\(t=mn=2\\times 3=6\\)\n\\[\n\\vec{x}=(a_{11},a_{12},a_{13},a_{21},a_{22},a_{23})\n\\]\n\n\nExample 6 If \\(A\\in\\mathscr{M}_3(\\mathbb{R})\\) s.t.\n\\[\nA=  \\left(\\begin{array}{ccc}\na_{11} & a_{12} & a_{13}\\\\\na_{21} & a_{22} & a_{23}\\\\\na_{31} & a_{32} & a_{33}\n\\end{array}\\right)\n\\]\nthen the pseudomatrix of \\(A\\) is a vector \\(\\vec{x}\\in\\mathbb{R}^{t}\\) for \\(t=mn=3\\times3=9\\) and \\(\\vec{x}=(x_{f(1,1)},x_{f(1,2)},\\ldots,x_{f(3,3)})\\). Since we start counting from \\(1\\), then \\(f(i,j)\\coloneqq(i-1)n+j\\). Thus,\n\\[\n\\begin{align}\nf(1,1)  &=(1-1)3+1=0\\times3+1=0+1=1\\Rightarrow x_{1}=a_{11}\\\\\nf(1,2)  &=(1-1)3+2=0\\times3+2=0+2=2\\Rightarrow x_{2}=a_{12}\\\\\nf(1,3)  &=(1-1)3+3=0\\times3+3=0+3=3\\Rightarrow x_{3}=a_{13}\\\\\nf(2,1)  &=(2-1)3+1=1\\times3+1=3+1=4\\Rightarrow x_{4}=a_{21}\\\\\nf(2,2)  &=(2-1)3+2=1\\times3+2=3+2=5\\Rightarrow x_{5}=a_{22}\\\\\nf(2,3)  &=(2-1)3+3=1\\times3+3=3+3=6\\Rightarrow x_{6}=a_{23}\\\\\nf(3,1)  &=(3-1)3+1=2\\times3+1=6+1=7\\Rightarrow x_{7}=a_{31}\\\\\nf(3,2)  &=(3-1)3+2=2\\times3+2=6+2=8\\Rightarrow x_{8}=a_{32}\\\\\nf(3,3)  &=(3-1)3+3=2\\times3+3=6+3=9\\Rightarrow x_{9}=a_{33}\n\\end{align}\n\\]\nthereby, the pseudomatrix of A is a vector \\(\\vec{x}=(x_{1},x_{2},\\ldots,x_{9})\\) s.t.\n\\[\n\\vec{x}=(a_{11},a_{12},a_{13},a_{21},a_{22},a_{23},a_{31},a_{32},a_{33})\n\\]\n\n\nExample 7 Suppose that \\(A\\in\\mathscr{M}_2\\) s.t.\n\\[\nA = \\left(\\begin{array}{cc}\na_{00} & a_{01} \\\\\na_{10} & a_{11}\n\\end{array}\\right)\n\\]\nthen the pseudomatrix of \\(A\\) is a vector \\(\\vec{x}\\in\\mathbb{R}^{t}\\) where \\(t=2\\times2=4\\) and \\(\\vec{x}=(x_{f(0,0)},x_{f(0,1)},x_{f(1,0)},x_{f(1,1)})\\). Since we start counting from \\(0\\), then \\(f(i,j)=in+j\\). Thus\n\\[\n\\begin{align}\nf(0,0)  &=0\\times2+0=0+0=0\\Rightarrow x_{0}=a_{00}\\\\\nf(0,1)  &=0\\times2+1=0+1=1\\Rightarrow x_{1}=a_{01}\\\\\nf(1,0)  &=1\\times2+0=2+0=2\\Rightarrow x_{2}=a_{10}\\\\\nf(1,1)  &=1\\times2+1=2+1=3\\Rightarrow x_{3}=a_{11}\n\\end{align}\n\\]\nthereby, the pseudomatrix of \\(A\\) is a vector \\(\\vec{x}=(x_{0,}x_{1},x_{2},x_{3})\\) s.t. \\(\\vec{x}=(a_{00},a_{01},a_{10},a_{11})\\)."
  },
  {
    "objectID": "paper/index.html",
    "href": "paper/index.html",
    "title": "Riset Fahlevisia",
    "section": "",
    "text": "Artikel (riset) dengan topik (tapi tidak terbatas pada) komputasi evolusioner (evolutionary computation), analisis numerik (numerical analysis), dan optimisasi (optimization).\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nIkhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman\n\n\nDaftar Kajian Buku yang Pembaca Menggarisbawahinya\n\n\n\n\nIslam\n\n\nIlmu\n\n\nIkhtisar\n\n\nBahasa Indonesia\n\n\n\n\n\nIlmu adalah satu kata yang sudah tidak asing didengar oleh telinga. Meskipun demikian, kata ini memiliki kajian yang begitu dalam dan tidak sederhana. Dengan satu kata ini, yaitu ilmu, Dr.¬†Wendi Zarman menulis buku dengan judul \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" yang sudah penulis baca berulang-ulang. Di dalam buku ini, terdapat pembahasan mengenai ilmu, ulama terdahulu, dan apa kaitannya dengan seorang muslim, yang dibahas secara kukuh. Di antara kajian buku ini, terdapat kajian yang penulis ikhtisar menggarisbawahi, mencatat garis besar, dan halamannya. Kumpulan catatan-catatan garis besar inilah yang penulis ikhtisar susun dalam bentuk ikhtisar, dan penulis ikhtisar tulis dalam bentuk artikel yang juga memuat resensi buku.\n\n\n\n\n\n\n\nJun 3, 2024\n\n\nMuhammad Reza Fahlevi \n\nVerified\n\n\n\n\n\n\n\n\n  \n\n\n\n\nThe Description of Every Constructors, Functions Member, and Functions of Limav\n\n\nLearning limav.h through example and do it, the C++ header to do a computation of vectors and matrix.\n\n\n\n\nC++\n\n\nLinear Algebra\n\n\nMatrix\n\n\nTools\n\n\nVectors\n\n\n\n\n\nThere is no other way to be better at coding but to keep practice. In this article we disuss about C++ header that we had developed limav.h, an extension of std::vector&lt;double&gt; to do a computation of vectors and matrix in linear algebra. Here, we provide how to install and use limav.h and a description of every constructors, functions member, and functions of limav.h along with its simple example and the output as well. The goal of this article is to be a source of learning limav.h for those who like to do something by do it.\n\n\n\n\n\n\n\nApr 28, 2024\n\n\nMuhammad Reza Fahlevi \n\nVerified\n\n\n\n\n\n\n\n\n  \n\n\n\n\nLimav: Computation of Vectors and Matrix in Linear Algebra\n\n\nA C++ header file to construct vectors and matrix\n\n\n\n\nC++\n\n\nLinear Algebra\n\n\nMatrix\n\n\nTools\n\n\nVectors\n\n\n\n\n\nDeveloping a C++ header is a good practice and we do this at least once in a lifetime. In this paper, we develope our own C++ header to do a numerical computation of linear algebra by making our own C++ header that capable to construct two mathematical objects that mainly used in linear algebra, these are matrix and vectors. Once we have established our own C++ header, we may do a vast application of matrix and vectors by using our own C++ header as a form of intellectual satisfaction.\n\n\n\n\n\n\n\nApr 7, 2024\n\n\nMuhammad Reza Fahlevi \n\nVerified\n\n\n\n\n\n\n\n\n  \n\n\n\n\nLinav: Computation of Vectors in Linear Algebra\n\n\nA C++ header file as an extension of std::vector&lt;double&gt;\n\n\n\n\nC++\n\n\nLinear Algebra\n\n\nTools\n\n\nVectors\n\n\n\n\n\nC++ is one of favorite programming language for those who are having good understanding in algorithms and interested in computing something manually. One of advantage to do computation by using C++ is its speed when execute the program, it is suitable for approximating hard real-parameter optimization problem. It is so often that such a problem is formulated in the form of vectors, and main operators used in vectors are pointwise (elementwise) addition and s-multiplication. Eventhough there are library out there to do so, it is a good practice to develope our own C++ header for computation of vectors in linear algebra, at least once in a lifetime. By using our own C++ header, it is possible to do a computation of vectors, especially to compute the pointwise addition and s-multiplication which is make it opens a great possibility of interesting application thereof.\n\n\n\n\n\n\n\nFeb 12, 2024\n\n\nMuhammad Reza Fahlevi \n\nVerified\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fahlevisia",
    "section": "",
    "text": "Pembuka\n\nSelamat datang pembaca yang terhormat, kami melestarikan manuskrip yang kami punya yang telah kami digitalisasi dalam bentuk sebagai berikut:\n\n    \n         Artikel\n        \n            Artikel-artikel (ilmiah) dengan topik komputasi evolusioner, analisis numerik, dan optimisasi\n        \n         Buku Catatan\n        \n            Berisikan demonstrasi suatu komputasi yang dilestarikan dalam bentuk pemograman literasi (literate programming). Buku catatan ini ditulis dengan menggunakan  quarto markdown (.qmd) dan pluto notebook (pluto.jl).\n        \n         Blog\n        Berisikan pembaruan, pendapat, komentar, dan pemikiran kami\n         Himpunan Data\n        \n            Data repositori yang kami punya yang diperoleh dari experimen yang telah dilakukan. Kami mencatat data yang diperoleh dalam bentuk format berkas .csv\n        \n    \n\n\nApa itu Fahlevisia\n\n\nFahlevisia merupakan situs web personal untuk melestarikan manuskrip-manuskrip kami yang telah kami lestarikan dalam bentuk dokumen-dokumen daring seperti artikel, buku catatan, weblog (blog), dan himpunan data. Jadi, para pembaca yang terhormat dapat mengakses dokumen-dokumen ini secara daring. Fahlevisia diambil dari nama belakang pendiri situs web ini, M.R. Fahlevi, yang kemudian digabungkan dengan akhiran sia. Dengan demikian, Fahlevisia artinya situs web repositori personal M.R. Fahlevi. \n\\(\\qquad\\)Kebanyakan dari manuskrip kami (jika tidak semua) berlisensi di bawah Attribution-NonCommercial-ShareAlike 4.0 International (Atribusi-NonKomersial-BerbagiSerupa 4.0 Internasional). Kami berusaha sebaik mungkin untuk melestarikan manuskrip-manuskrip kami dapat dipahami baik oleh pembaca yang terhormat maupun mesin (machine readable). Agar dokumen-dokumen ini dapat dibaca oleh mesin, kami menggunakan teknologi Web Semantik (Semantic Web, Web 3.0, sekarang lebih dikenal dengan istilah web of data) berikut:\n\n\nLinked Data and Linked Data Principles.\n\n\nResource Description Framework (RDF).\n\n\nRDF in attributes (RDFa).\n\n\nJavascript Object Notation for Linked-Data (JSON-LD).\n\n\ndan kebanyakan kosakata (vocabularies) yang kami gunakan untuk mendeskripsikan metadata merupakan kosakata yang disediakan oleh schema dan the open graph protocol. Sebagian dari dokumen-dokumen ini tersedia dalam bahasa Indonesia dan bahasa Inggris.\n\\(\\qquad\\)Situs web Fahlevisia tidak meletakkan iklan apa saja, karena kami menginginkan para pembaca yang terhormat merasakan kenyamanan berinternet tanpa iklan. Kami juga ingin mengingatkan masyarakat tentang kenyamanan ini, yang mana kita tidak (sering) diganggu oleh iklan saat berinternet.\n\n\n\n\nTujuan Fahlevisia\n\nFahlevisia memiliki tujuan untuk ikut serta dalam melindungi bangsa Indonesia dari ketidaktahuan atas ilmu pengetahuan dan teknologi, dan mencerdaskan kehidupan bangsa Indonesia, sebagaimana tertera dalam Pembukaaan Undang-Undang Dasar Negara Republik Indonesia Tahun 1945, alinea ke 4, yaitu\n\nKemudian daripada itu untuk membentuk suatu Pemerintah Negara Indonesia yang melindungi segenap bangsa Indonesia dan seluruh tumpah darah Indonesia dan untuk memajukan kesejahteraan umum, mencerdaskan kehidupan bangsa, dan ikut serta melaksanakan ketertiban dunia yang berdasarkan kemerdekaan, perdamaian abadi dan keadilan sosial, ‚Ä¶\n\n\\(\\qquad\\)Untuk mencapai tujuan tersebut, kami melestarikan manuskrip-manuskrip kami dalam bentuk dokumen-dokumen daring yaitu, artikel, buku catatan, dan himpunan data. Yang mana, melalui dokumen-dokumen daring ini, kami berusaha sebaik mungkin untuk menyebarluaskan ilmu pengetahuan yang berbahasa Indonesia dan memiliki kualitas yang setara dengan kualitas artikel daring luar negeri pada umumnya.\n\\(\\qquad\\)Dikarenakan keterbatasan ilmu pengetahuan kami, kami hanya ikut serta dalam melindungi bangsa Indonesia dari ketidaktahuan atas ilmu pengetahuan di bidang ilmu komputer dan teknologi. Bahkan lebih spesifik lagi, yaitu, untuk ilmu komputer kami lebih spesifik di bidang analisis numerik, (meta) heuristik, komputasi evolusioner \\(\\textemdash\\) strategi evolusi dan algoritma genetika \\(\\textemdash\\) dan optimisasi. Pada bidang teknologi, kami lebih spesifik pada pengembangan web, pemrograman berorientasi objek, dan komputasi saintifik.\n\\(\\qquad\\)Sedangkan weblog (blog), memiliki tujuan untuk melestarikan manuskrip-manuskrip kami dalam bentuk dokumen daring yang berisikan opini, apa yang baru di situs web ini, dan pemikiran kami. Blog (kami) juga lebih cenderung sebagai jurnal personal. Jadi, di dalam blog ini juga dapat berisikan tulisan pengalaman/cerita kami, dan topik yang dibahas juga lebih bervariasi.\n\n\n\nHak Cipta\n\nSemua karya tulis situs web Fahlevisia dilindungi oleh Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta.\n\n\nSetiap Orang yang dengan tanpa hak dan/atau tanpa izin Pencipta atau pemegang Hak Cipta melakukan pelanggaran hak ekonomi Pencipta sebagaimana dimaksud dalam Pasal 9 ayat (1) huruf a, huruf b, huruf c, dan/atau huruf g untuk Penggunaan Secara Komersial dipidana dengan pidana penjara paling lama 4 (empat) tahun dan/atau pidana denda paling banyak Rp1.000.000.000,00 (satu miliar rupiah).\n\n\n\n-UU No.¬†28 Tahun 2014 tentang Hak Cipta Pasal 113 ayat (3)-  Baca selengkapnya &gt;&gt;\n\n\n\n\n\nDukung Fahlevisia\n\n    \n    Fahlevisia\n    Repositori Digital Personal\n    Do you like what you have read?You may treat the author a cup of coffee as a form of thank you\n    \n         Treate the author a cup of coffee\n    \n    Fahlevisia is thanked to the honourable reader who support us and/or dedicate some of his/her time reading our article."
  },
  {
    "objectID": "hukum.html",
    "href": "hukum.html",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "",
    "text": "Undang-undang ini mengatur:\n\na. Hak Cipta; dan b. Hak Terkait"
  },
  {
    "objectID": "hukum.html#pasal-3",
    "href": "hukum.html#pasal-3",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "",
    "text": "Undang-undang ini mengatur:\n\na. Hak Cipta; dan b. Hak Terkait"
  },
  {
    "objectID": "hukum.html#pasal-4",
    "href": "hukum.html#pasal-4",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 4",
    "text": "Pasal 4\nHak Cipta sebagaimana dimaksud dalam Pasal 3 huruf a merupakan hak eksklusif yang terdiri atas hak moral dan hak ekonomi."
  },
  {
    "objectID": "hukum.html#pasal-5",
    "href": "hukum.html#pasal-5",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 5",
    "text": "Pasal 5\n\n\nHak moral sebagaimana yang dimaksud dalam Pasal 4 merupakan hak yang hak yang melekat secara abadi pada diri Pencipta untuk:\n\n\n\n\ntetap mencantumkan atau tidak mencantumkan namanya pada salinan sehubungan dengan pemakaian Ciptaannya untuk umum;\nmenggunakan nama aliasnya atau samarannya;\nmengubah Ciptaanya sesuai dengan kepatutan dalam masyarakat;\nmengubah judul dan anak judul Ciptaan; dan\nmempertahankan haknya dalam hal terjadi distorsi Ciptaan, mutilasi Ciptaan, modifikasi Ciptaan, atau hal yang bersifat merugikan kehormatan diri atau reputasinya.\n\n\n\n\nHak moral sebagaiman dimaksud pada ayat (1) tidak dapat dialihkan selama Pencipta masih hidup, tetapi pelaksanaan hak tersebut dapat dialihkan dengan wasiat atau sebab lain sesuai dengan ketentuan peraturan perundag-undangan setelah Pencipta meninggal dunia.\nDalam hal terjadi pengalihan pelaksanaan hak moral sebagaimana dimaksud pada ayat (2), penerima dapat melepaskan atau menolak pelaksanaan haknya dengan syarat pelepasan atau penolakan pelaksanaan hak tersebut dinyatakan secara tertulis."
  },
  {
    "objectID": "hukum.html#pasal-8",
    "href": "hukum.html#pasal-8",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 8",
    "text": "Pasal 8\nHak ekonomi merupakan hak eksklusif Pencipta atau Pemegang Hak Cipta untuk mendapatkan manfaat ekonomi atas Ciptaan."
  },
  {
    "objectID": "hukum.html#pasal-9",
    "href": "hukum.html#pasal-9",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 9",
    "text": "Pasal 9\n\n\nPencipta atau Pemegang Hak Cipta sebagaimana dimaksud dalam Pasal 8 memiliki hak ekonomi untuk melakukan:\n\n\n\n\npenerbitan Ciptaan;\npenggandaan Ciptaaan dalam segala bentuknya;\npenerjemahan Ciptaan;\npengadaptasian, pengarasemenan, atau pentransformasian Ciptaan;\nPendistribusian Ciptaan atau salinanya;\npertunjukan Ciptaan;\nPengumuman Ciptaan;\nKomunikasi Ciptaan; dan\npenyewaan Ciptaan.\n\n\n\n\nSetiap Orang yang melaksanakan hak ekonomi sebagaimana dimaksud pada ayat (1) wajib mendapatkan izin Pencipta atau Pemegang Hak Cipta.\nSetiap Orang yang tanpa izin Pencipta atau Pemegang Hak Cipta dilarang melakukan Penggandaan dan/atau Penggunaan Secara Komersial Ciptaan."
  },
  {
    "objectID": "hukum.html#pasal-10",
    "href": "hukum.html#pasal-10",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 10",
    "text": "Pasal 10\nPengelola tempat perdagangan dilarang membiarkan penjualan dan/atau penggandaan barang hasil pelanggaran Hak Cipta dan/atau Hak Terkait di tempat perdagangan yang dikelolanya."
  },
  {
    "objectID": "hukum.html#pasal-31",
    "href": "hukum.html#pasal-31",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 31",
    "text": "Pasal 31\nKecuali terbukti sebaliknya, yang dianggap sebagai Pencipta, yaitu Orang yang namanya:\n\na. disebut dalam Ciptaan; b. dinyatakan sebagai Pencipta pada suatu Ciptaan; c.¬†disebutkan dalam surat pencatatan Ciptaan; dan/atau  d.¬†tercantum dalam daftar umum Ciptaan sebagai Pencipta."
  },
  {
    "objectID": "hukum.html#pasal-40",
    "href": "hukum.html#pasal-40",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 40",
    "text": "Pasal 40\n\n\n\nCiptaan yang dilindungi meliputi Ciptaan dalam bidang ilmu pengetahuan, seni, dan sastra, terdiri atas:\n\n\n\na. buku, pamflet, perwajahan karya tulis yang diterbitkan, dan semua hasil karya tulis lainnya; b. ceramah, kuliah, pidato, dan Ciptaan sejenis lainnya; c.¬†alat peraga yang dibuat untuk kepentingan pendidikan dan ilmu pengetahuan; d.¬†lagu dan/atau musik dengan atau tanpa teks; e. drama, drama musikal, tari, koreografi, pewayangan, dan pantomim; f.¬†karya seni rupa dalam segala bentuk seperti lukisan, gambar, ukiran, kaligrafi, seni pahat, patung, atau kolasi; g. karya seni terapan; h. karya arsitektur; i. peta; j. karya seni batik atau seni motif lain; k. karya fotografi; l. Potret; m. karya sinematografi; n.¬†terjemahan, tafsir, saduran bunga rampai, basis data, adaptasi, aransemen, modifikasi dan karya lain dari hasil transformasi; o. terjemahan, adaptasi, aransemen, transformasi, atau modifikiasi ekspresi budaya tradisional; p.¬†kompilasi Ciptaan atau data, baik dalam format yang dapat dibaca dengan Program Komputer maupun media lainnya; q. kompilasi ekspresi budaya tradisional selama kompilasi tersebut merupakan karya yang asli; r. permainan video; dan s. Program Komputer.\n\n\n\nCiptaan sebagaimana dimaksud pada ayat 1 huruf n dilindungi sebagai Ciptaan tersendiri dengan tidak mengurangi Hak Cipta atas Ciptaan asli.\nPelindungan sebagaimana dimaksud pada ayat (1) dan ayat (2), termasuk pelindungan terhadap Ciptaan yang tidak atau belum dilakukan Pengumuman tetapi sudah diwujudkan dalam bentuk nyata yang memungkinkan Penggandaan Ciptaan tersebut."
  },
  {
    "objectID": "hukum.html#pasal-42",
    "href": "hukum.html#pasal-42",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 42",
    "text": "Pasal 42\nTidak ada Hak Cipta atas hasil karya berupa:\n\n\n\nhasil rapat terbuka lembaga negara;\n\n\nperaturan perundang-undangan;\n\n\npidato kenegaraan atau pidato pejabat pemerintah;\n\n\nputusan pengadilan atau penetapan hakim;\n\n\nkitab suci atau simbol keagamaan."
  },
  {
    "objectID": "hukum.html#pasal-48",
    "href": "hukum.html#pasal-48",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 48",
    "text": "Pasal 48\nPenggandaan, Penyiaran, atau Komunikasi atas Ciptaan untuk tujuan informasi yang menyebutkan sumber dan nama Pencipta secara lengkap tidak dianggap pelanggaran Hak Cipta dengan ketentuan Ciptaan berupa:\n\n\nartikel dalam berbagai bidang yang sudah dilakukan Pengumuman baik dalam media cetak maupun media elektronik kecuali yang salinannya disediakan oleh Pencipta, atau berhubungan dengan Penyiaran atau Komunikasi atas suatu Ciptaan;\nlaporan peristiwa aktual atau kutipan singkat dari Ciptaan yang dilihat atau didengar dalam situasi tertentu;\nkarya ilmiah, pidato, ceramah, atau Ciptaan sejenis yang disampaikan kepada publik."
  },
  {
    "objectID": "hukum.html#pasal-52",
    "href": "hukum.html#pasal-52",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 52",
    "text": "Pasal 52\n\nSetiap Orang dilarang merusak, memusnahkan, menghilangkan, atau membuat tidak berfungsi sarana kontrol teknologi yang digunakan sebagai pelindung Ciptaan atau produk Hak Terkait serta pengaman Hak Cipta atau Hak Terkait, kecuali untuk kepentingan pertahanan dan keamanan negara, serta sebab lain sesuai dengan ketentuan peraturan perundang-undangan, atau diperjanjikan lain."
  },
  {
    "objectID": "hukum.html#pasal-64",
    "href": "hukum.html#pasal-64",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 64",
    "text": "Pasal 64\n\n\nMenteri menyelenggarakan Pencatatan dan Penghapusan Ciptaan dan produk Hak Terkait.\nPencatatan Ciptaan dan produk Hak Terkait sebagaimana dimaksud pada ayat (1) bukan merupakan syarat untuk mendapatkan Hak Cipta dan Hak Terkait.\n\n\n\nPenjelasan atas UU No.¬†28 Tahun 2014 tentang Hak Cipta Pasal 64 ayat (2)\n\nPencatatan Ciptaan dan produk Hak Terkait bukan merupakan suatu keharusan bagi Pencipta, Pemegang Hak Cipta atau pemilik Hak Terkait. Pelindungan suatu Ciptaan dimulai sejak Ciptaan itu ada atau terwujud dan bukan karena pencatatan. Hal ini berarti suatu Ciptaan baik yang tercatat maupun tidak tercatat tetap dilindungi."
  },
  {
    "objectID": "hukum.html#pasal-112",
    "href": "hukum.html#pasal-112",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 112",
    "text": "Pasal 112\nSetiap Orang yang dengan tanpa hak melakukan perbuatan sebagaimana dimaksud dalam Pasal 7 ayat (3) dan/atau Pasal 52 untuk Penggunaan Secara Komersial, dipidana dengan pidana penjara paling lama 2 (dua) tahun dan/atau pidana denda paling banyak Rp300.000.000,00 (tiga ratus juta rupiah)."
  },
  {
    "objectID": "hukum.html#pasal-113",
    "href": "hukum.html#pasal-113",
    "title": "Undang-undang (UU) Nomor 28 Tahun 2014 tentang Hak Cipta",
    "section": "Pasal 113",
    "text": "Pasal 113\n\n\nSetiap Orang yang dengan tanpa hak melakukan pelanggaran hak ekonomi sebagaimana dimaksud dalam Pasal 9 ayat (1) huruf i untuk Penggunaan Secara Komersial dipidana dengan pidana penjara paling lama 1 (satu) tahun dan/atau pidana denda paling banyak Rp100.000.000 (seratus juta rupiah).\nSetiap Orang yang dengan tanpa hak dan/atau tanpa izin Pencipta atau pemegang Hak Cipta melakukan pelanggaran hak ekonomi Pencipta sebagaimana dimaksud dalam Pasal 9 ayat (1) huruf c, huruf d, huruf f, dan/atau huruf h untuk Penggunaan Secara Komersial dipidana dengan pidana penjara paling lama 3 (tiga) tahun dan/atau pidana denda paling banyak Rp500.000.000,00 (lima ratus juta rupiah).\nSetiap Orang yang dengan tanpa hak dan/atau tanpa izin Pencipta atau pemegang Hak Cipta melakukan pelanggaran hak ekonomi Pencipta sebagaimana dimaksud dalam Pasal 9 ayat (1) huruf a, huruf b, huruf c, dan/atau huruf g untuk Penggunaan Secara Komersial dipidana dengan pidana penjara paling lama 4 (empat) tahun dan/atau pidana denda paling banyak Rp1.000.000.000,00 (satu miliar rupiah).\nSetiap Orang yang memenuhi unsur sebagaimana dimaksud pada ayat (3) yang dilakukan dalam bentuk pembajakan, dipidana dengan pidanan penjara paling lama 10 (sepuluh) tahun dan/atau pidana denda paling banyak Rp4.000.000.000,00 (empat miliar rupiah)."
  },
  {
    "objectID": "paper/2024/fsr1/index.html",
    "href": "paper/2024/fsr1/index.html",
    "title": "Linav: Computation of Vectors in Linear Algebra",
    "section": "",
    "text": "Email\n        muhammadrezafahlevi666@gmail.com"
  },
  {
    "objectID": "paper/2024/fsr1/index.html#abstract-vector-space-and-space-of-mathbbrn",
    "href": "paper/2024/fsr1/index.html#abstract-vector-space-and-space-of-mathbbrn",
    "title": "Linav: Computation of Vectors in Linear Algebra",
    "section": "2.1 Abstract Vector Space and Space of \\(\\mathbb{R}^n\\)",
    "text": "2.1 Abstract Vector Space and Space of \\(\\mathbb{R}^n\\)\n\n\nDefinition 1 (abstract vector space) The vector space of a set \\(V\\) is the triplet \\((V,+,\\cdot)\\) where \\(+\\colon V\\times V\\to V\\) and \\(\\cdot\\colon \\mathbb{R}\\times V\\to V\\) are known as pointwise addition and s-multiplication, respectively. Which \\(\\forall\\vec{x},\\vec{y},\\vec{z}\\in V\\) and \\(\\forall\\lambda,\\mu\\in\\mathbb{R}\\) satisfy the following 8 axioms (Dadhley, R., 2019; K√∂rner, T.W., 2012).\n\n(1). [the commutative law] \\(\\vec{x}+\\vec{y}=\\vec{y}+\\vec{x}\\)  (2). [the associative law] \\((\\vec{x}+\\vec{y})+\\vec{z}=\\vec{x}+(\\vec{y}+\\vec{z})\\)  (3). [the existance of neutral element] \\(\\exists\\vec{0}\\in V\\colon\\forall\\vec{x}\\in V\\colon\\vec{x}+\\vec{0}=\\vec{x}\\)  (4). [the existance of inverse element] \\(\\forall\\vec{x}\\in V\\colon\\exists\\vec{x}^{\\prime}\\in V\\colon\\vec{x}+\\vec{x}^{\\prime}=\\vec{0}\\)  (5). [the associative law] \\(\\lambda\\cdot(\\mu\\cdot\\vec{x})=(\\lambda\\cdot\\mu)\\cdot\\vec{x}\\)  (6). [the distributive law] \\((\\lambda+\\mu)\\vec{\\cdot x}=\\lambda\\cdot\\vec{x}+\\mu\\cdot\\vec{x}\\)  (7). [the distributive law] \\(\\lambda\\cdot(\\vec{x}+\\vec{y})=\\lambda\\cdot\\vec{x}+\\lambda\\cdot\\vec{y}\\)  (8). [the existance of unitary element] \\(\\exists\\iota\\in\\mathbb{R}\\colon\\forall\\vec{x}\\in V\\colon\\iota\\cdot\\vec{x}=\\vec{x}\\)\n\n\n\nRemark. The element of vector space \\((V,+,\\cdot)\\) is called vector, conviniently.\n\n\nDefinition 2 Let \\((U,+,\\cdot)\\) and \\((V,+,\\cdot)\\) are vector spaces s.t. \\(U\\subseteq V\\), then \\(U\\) is defined as the subspace of \\(V\\).\n\n\nDefinition 3 The set \\(\\mathbb{R}^{n}\\coloneqq\\mathbb{R}\\times\\mathbb{R}\\times\\cdots\\times\\mathbb{R}\\) is the set of n-tuples of all real numbers i.e., \\[\n\\mathbb{R}^{n}\\coloneqq\\{(x_{1},x_{2},\\cdots,x_{n})\\colon\\forall i=1,2,\\ldots,n,\\,x_{i}\\in\\mathbb{R}\\}\n\\]\n\n\nRemark. One of special case of \\(\\mathbb{R}^{n}\\) is when \\(n=2\\) or \\(n=3\\), i.e., \\[\n\\mathbb{R}^{2}\\coloneqq\\{(x_{1},x_{2})\\colon x_{1},x_{2}\\in\\mathbb{R}\\}\\quad\\text{or }\\quad\\mathbb{R}^{3}\\coloneqq\\{(x_{1},x_{2},x_{3})\\colon x_{1},x_{2},x_{3}\\in\\mathbb{R}\\}\n\\]\nand the element of \\(\\mathbb{R}^{n}\\) is called a point in \\(\\mathbb{R}^{n}\\).\n\nNotation. n-tuple of a real number is denoted by a letter with an arrow on that letter. E.g., \\(\\vec{x},\\vec{y},\\vec{z},\\text{etc.}\\) Thereby, if \\(\\vec{x}\\in\\mathbb{R}^{3}\\) and \\(\\vec{y}\\in\\mathbb{R}^{3}\\) s.t. \\(\\vec{x}=(x_{1},x_{2})^{\\top}\\) and \\(\\vec{y}=(y_{1},y_{2},y_{3})^{\\top}\\), then \\(\\vec{x}\\) is a point in \\(\\mathbb{R}^{2}\\) and \\(\\vec{y}\\) is a point in \\(\\mathbb{R}^{3}\\).\nBy using the definition of abstract vector space, we are capable to construct the vector space of \\(\\mathbb{R}^{n}\\).\n\n\n\nExample 1 (\\(\\mathbb{R}^n\\) vector space) The following triplet \\((\\mathbb{R}^{n},+,\\cdot)\\) is a vector space s.t. if the pointwise addition and s-multiplication are defined as follows\n\n(i). [pointwise addition] \\(+\\colon\\mathbb{R}^{n}\\times\\mathbb{R}^{n}\\to\\mathbb{R}^{n}\\) s.t. \\[\n\\forall\\vec{x},\\vec{y}\\in\\mathbb{R}^{n}\\colon(\\vec{x},\\vec{y})\\mapsto\\vec{x}+\\vec{y}\\coloneqq(x_{1}+y_{1},x_{2}+y_{2},\\ldots,x_{n}+y_{n})^{\\top}\n\\tag{1}\\]\n(ii). [s-multiplication] \\(\\cdot\\colon\\mathbb{R}\\times\\mathbb{R}^{n}\\to\\mathbb{R}^{n}\\) s.t. \\[\n\\forall\\lambda\\in\\mathbb{\\mathbb{R}}\\colon\\forall\\vec{x}\\in\\mathbb{R}^{n}\\colon(\\lambda,\\vec{x})\\mapsto\\lambda\\cdot\\vec{x}=(\\lambda x_{1},\\lambda x_{2},\\ldots,\\lambda x_{n})^{\\top}\n\\tag{2}\\]\n\nthen it satisfy the 8 axioms stated in the definition of abstract vector spaces.\n\n\n\n\nProof. The existance of the neutral element for \\(\\mathbb{R}^{n}\\) is the \\(n\\)-tuple s.t. all elements such \\(n\\)-tuple are zero, i.e., \\(\\vec{0}=(0,0,\\ldots,0)^{\\top}.\\) If \\(\\vec{0}\\) is called as a null vector and \\(\\vec{0}\\in\\mathbb{R}^{n}\\), then \\(\\vec{0}\\) is defined as the null vector in \\(\\mathbb{R}^{n}\\). thus, \\(\\forall\\vec{x}\\in\\mathbb{R}^{n}\\colon\\vec{x}+\\vec{0}=\\vec{x}\\).\nThe existance of the inverse element can be showed by observing the s-multiplication of \\(\\forall\\vec{x}\\) by \\(-1\\) is \\(-\\vec{x}=(-x_{1},-x_{2},\\ldots,-x_{n})^{\\top}\\) and \\(-\\vec{x}\\in\\mathbb{R}^{n}\\). Thus, \\(\\forall\\vec{x}\\in\\mathbb{R}\\colon\\vec{x}+(-1)\\cdot\\vec{x}=\\vec{0}\\).\nThe existance of unitary element of \\(\\mathbb{R}\\) is \\(1\\), so we have that \\(\\forall\\vec{x}\\in\\mathbb{R}^{n}\\colon1\\cdot\\vec{x}=\\vec{x}\\). The rest is trivial. After checking all \\(8\\)-axioms stated in the definition of abstract vector space (Definition¬†1), we have that the following triplet \\((\\mathbb{R}^{n},+,\\cdot)\\) indeed a vector spaces.\n\n\\(\\square\\)"
  },
  {
    "objectID": "paper/2024/fsr1/index.html#pointwise-operators-from-mathbbrn-to-itself",
    "href": "paper/2024/fsr1/index.html#pointwise-operators-from-mathbbrn-to-itself",
    "title": "Linav: Computation of Vectors in Linear Algebra",
    "section": "2.2 Pointwise Operators from \\(\\mathbb{R}^n\\) to Itself",
    "text": "2.2 Pointwise Operators from \\(\\mathbb{R}^n\\) to Itself\n\nFrom previous section we have seen 2 pointwise operators namely, pointwise addition and s-multiplication. Notice that these operators are not addition and multiplication of real numbers, instead, pointwise addition operator is addition for vector space. Similarly, the s-multiplication is multiplication of real number and vector which yields a vector.\n\\(\\quad\\) In order to understand what we mean by this, observe the distributive law in the definition of vector space, it‚Äôs stated that \\(\\forall\\vec{x}\\in V,\\forall\\lambda,\\mu\\in\\mathbb{R}\\colon(\\lambda+\\mu)\\cdot\\vec{x}=\\lambda\\cdot\\vec{x}+\\mu\\cdot\\vec{x}\\), more explicitly, this axiom can be rewritten as follow\n\\[\n\\forall\\vec{x}\\in V\\colon\\forall\\lambda,\\mu\\in\\mathbb{R}\\colon(\\lambda+_{\\mathbb{R}}\\mu)\\cdot_{V}\\vec{x}=\\lambda\\cdot_{V}\\vec{x}+_{V}\\mu\\cdot_{V}\\vec{x}\n\\tag{3}\\]\nobserve the subscript of each operator. On the left hand side, we have that \\(+_{\\mathbb{R}}\\) is addition operator on two real numbers, meanwhile, on the right hand side, we only have \\(+_{V}\\) which is pointwise addition, for which it‚Äôs addition on the vector space \\(V\\), which is different from \\(+_{\\mathbb{R}}\\).\n\\(\\quad\\) For the case of s-multiplication, observe the associative law in the definition of vector space, this axiom can be rewritten more explicitly as follow\n\\[\n\\forall\\vec{x}\\in\\mathbb{R}^{n}\\colon\\forall\\lambda,\\mu\\in\\mathbb{R}\\colon(\\lambda\\cdot_{\\mathbb{R}}\\mu)\\cdot_{V}\\vec{x}=\\lambda\\cdot_{V}(\\mu\\cdot_{V}\\vec{x})\n\\tag{4}\\]\non the left hand side, we have \\(\\cdot_{\\mathbb{R}}\\) on \\((\\lambda\\cdot_{\\mathbb{R}}\\mu)\\) which is multiplication of 2 real numbers, meanwhile, on the right hand side we only have \\(\\cdot_{V}\\) which is s-multiplication, a multiplication of real number and vector which yields a vector, and it‚Äôs different multiplication from \\(\\cdot_{\\mathbb{R}}\\).\n\\(\\quad\\) At the first glimpse, perharps our honorable readers think these are just what every gentleman and lady know, the subscript on the pointwise addition and s-multiplication i.e., \\(+_{V}\\) and \\(\\cdot_{V}\\) just ‚Äúunnecessary abstraction‚Äù, apperently. However, in the computation point of view‚Äî which is application of these ‚Äúunnecessary abstraction‚Äù‚Äîit turn out that it serves clarity of what kind of object that we need, and what operators which take those object as its input and what kind of object that the output will produce (Dadhley, R., 2019). Another operators which take a vector as its input and produce a vector beside pointwise addition and s-multiplication are pointwise subtraction, multiplication, powered by, absolute value, and normalize vector.\n\\(\\quad\\) We compute the pointwise addition as it is defined, and so for the s-multiplication, i.e, for pointwise addition we have 2 vectors, and then we define a vector which is the addition 2 vectors thereof. Similarly, for s-multiplication, we have a vector and a real number, then we define a vector which is a vector obtained from a vector we have and its components are multiplied by a real number (see Example¬†1).\n\\(\\quad\\) Theoritically, pointwise substraction is a composition of pointwise addition and s-multiplication of two vectors, \\(-_{V}\\equiv+_{V}\\circ\\cdot_{V}\\) i.e, a pointwise addition after s-multiplication of \\(2\\) vectors. So, the \\(-_{V}\\) theoritically defined as\n\\[\n-_{V}   \\equiv+\\circ\\cdot\\colon V\\times (\\mathbb{R}\\times V)\\to V\n\\tag{5}\\]\ns.t.\n\\[\n\\exists\\lambda\\colon\\forall\\vec{x}\\colon\\forall\\vec{y}\\colon(\\vec{x},(\\lambda,\\vec{y}))\\mapsto(\\vec{x},\\lambda\\cdot\\vec{y})\\mapsto\\vec{x}+\\lambda\\cdot\\vec{y}\n\\tag{6}\\]\nby set \\(\\lambda=-1\\), thus\n\\[\n-_{V}(\\vec{x},\\vec{y})\\equiv\\vec{x}+(-1)\\vec{y}\\eqqcolon\\vec{x}-\\vec{y}\n\\tag{7}\\]\nNevertheless, it‚Äôs not practical to compute the pointwise substraction by taking the s-multiplication of vector by \\(-1\\) and then take its pointwise addition by vector, instead, we just compute the pointwise substraction as we compute the pointwise addition, but we use \\(-\\) operator on its elements, i.e., if \\(\\vec{x}=(x_{1,}x_{2},\\ldots,x_{n})^{\\top}\\) and \\(\\vec{y}=(y_{1},y_{2},\\ldots,y_{n})^{\\top}\\), then the pointwise substraction is a map \\(-\\colon V\\times V \\to V\\) s.t.\n\\[\n(\\vec{x},\\vec{y})\\mapsto\\vec{x}-\\vec{y}\\coloneqq(x_{1}-y_{1},x_{2}-y_{2},\\ldots,x_{n}-y_{n})^{\\top}\n\\tag{8}\\]\n\nDefinition 4 Let \\(\\vec{x},\\vec{y}\\in\\mathbb{R}^{n}\\) and \\(\\lambda\\in\\mathbb{R}\\), the following are elementwise multiplication, powered by, and absolute value operators for vectors, its map, and its computation.\n\n(1). [elementwise multiplication] \\(\\ast\\colon V\\times V \\to V\\) s.t.\n\\[\n(\\vec{x},\\vec{y})\\mapsto\\vec{x}\\ast\\vec{y}\\coloneqq(x_{1}y_{1},x_{2}y_{2},\\ldots,x_{n}y_{n})^{\\top}\n\\tag{9}\\]\n(2). [elementwise powered by] \\(\\text{pow}(\\cdot,\\cdot)\\colon V\\times\\mathbb{R} \\to V\\) s.t.\n\\[\n(\\vec{x},\\lambda)\\mapsto\\text{pow}(\\vec{x},\\lambda)\\coloneqq(x_{1}^{\\lambda},x_{2}^{\\lambda},\\ldots,x_{n}^{\\lambda})^{\\top}\n\\tag{10}\\]\n(3). [elementwise absolute value] \\(\\text{abs}(\\cdot)\\colon V \\to V\\) s.t.\n\\[\n\\vec{x}\\mapsto\\text{abs}(\\vec{x})\\coloneqq(\\vert x_{1}\\vert,\\vert x_{2}\\vert,\\ldots,\\vert x_{n}\\vert)^{\\top}\n\\tag{11}\\]\n\n\nwe use these operators as it is to do a computation of 2 vectors when involving these operators."
  },
  {
    "objectID": "paper/2024/fsr1/index.html#linear-maps",
    "href": "paper/2024/fsr1/index.html#linear-maps",
    "title": "Linav: Computation of Vectors in Linear Algebra",
    "section": "2.3 Linear Maps",
    "text": "2.3 Linear Maps\n\n\nDefinition 5 (linear maps) Suppose that \\((V,+,\\cdot)\\) and \\((W,+,\\cdot)\\) are vector spaces, let \\(\\vec{x},\\vec{y}\\in\\mathbb{R}\\) and \\(\\lambda\\in\\mathbb{R}\\), then a map \\(\\phi\\colon V\\to W\\) is linear if and only if \\(\\phi\\) satisfy the following properties (K√∂rner, T.W., 2012):\n\n(1). \\(\\phi(\\vec{x}+\\vec{y})=\\phi(\\vec{x})+\\phi(\\vec{y})\\)  (2). \\(\\phi(\\lambda\\vec{x})=\\lambda\\phi(\\vec{x})\\)\n\n\n\nDefinition 6 (sum of component) Let \\((\\mathbb{R}^{n},+,\\cdot)\\) be vector space and \\(\\vec{x}\\in\\mathbb{R}^{n}\\), then the sum of component of a vector \\(\\vec{x}\\) is defined as \\(\\text{sum}(\\cdot)\\colon\\mathbb{R}^{n}\\to\\mathbb{R}\\) s.t.\n\\[\n\\vec{x}\\mapsto\\text{sum}(\\vec{x})\\coloneqq\\sum_{i=1}^{n}x_{i}=x_{1}+x_{2}+\\cdots+x_{n}\n\\tag{12}\\]\nfor \\(\\vec{x}=(x_1,x_2,\\ldots,x_n)^\\top\\).\n\n\nLemma 1 The sum of component of a vector i.e., \\(\\text{sum}(\\cdot)\\) is a linear map.\n\n\nProof. In order to prove either a map is linear or not, then we must check such a map satisfy the definition of a linear map. To do so, let \\((\\mathbb{R}^{n},+,\\cdot)\\) be vector space.\n\n(1). Observe that for \\(\\text{sum}(\\cdot)\\colon\\mathbb{R}^{n}\\to\\mathbb{R}\\), by definition\n\\[\n\\begin{align}\n\\forall\\vec{x},\\vec{y}\\in\\mathbb{R}^{n}\\colon\\text{sum}(\\vec{x}+\\vec{y}) &= \\sum_{i=1}^{n}(x_{i}+y_{i}) \\\\\n&= \\sum_{i=1}^{n}x_{i}+\\sum_{i=1}^{n}y_{i} \\\\\n\\text{sum}(\\vec{x}+\\vec{y}) &= \\text{sum}(\\vec{x})+\\text{sum}(\\vec{y})\n\\end{align}\n\\]\n(2). Observe that\n\\[\n\\begin{align}\n\\forall\\vec{x}\\in\\mathbb{R}^{n}\\colon\\forall\\lambda\\in\\mathbb{R}\\colon \\text{sum}(\\lambda\\vec{x}) &= \\sum_{i=1}^{n}\\lambda x_{i} \\\\\n&= \\lambda\\sum_{i=1}^{n}x_{i} \\\\\n\\text{sum}(\\lambda\\vec{x}) &= \\lambda\\text{ sum}(\\vec{x})\n\\end{align}\n\\]\n\nThereby, the sum of component operator satisfy definition of a linear map.\n\n\\(\\square\\)\n\n\n\\(\\quad\\) Theoritically, it‚Äôs okay to compute the sum of component by using Definition¬†6 as it is. However, it is not so when we attempt to compute it by using a programming language like C++. Due to numerical issue, we compute the sum of component \\(\\text{sum}(\\cdot)\\colon\\mathbb{R}^{n}\\to\\mathbb{R}\\) by using Kahan‚Äôs sum algorithm as follows (Solomon, J., 2015).\n    \\begin{algorithm}\n    \\caption{Kahan's sum, $\\text{sum}(\\cdot)\\colon\\mathbb{R}^{n}\\to\\mathbb{R}$}\n    \\begin{algorithmic}\n    \\STATE Define $\\vec{x}\\in\\mathbb{R}^{n}$ s.t., $\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})^{\\top}$\n    \\STATE Let $s,s_{\\text{next}},c\\in\\mathbb{R}$ s.t. $s,s_{\\text{next}},c\\longleftarrow0$\n    \\FOR{$i\\longleftarrow1,2,\\ldots,n$}\n        \\STATE $v\\longleftarrow x_{i}+c$\n        \\STATE $s_{\\text{next}}\\longleftarrow s+v$\n        \\STATE $c\\longleftarrow v-(s_{\\text{next}}-s)$\n        \\STATE $s\\longleftarrow s_{\\text{next}}$\n    \\ENDFOR\n    \\RETURN $s$\n    \\end{algorithmic}\n    \\end{algorithm}\n\n\nDefinition 7 (the inner product) Let \\((\\mathbb{R}^{n},+,\\cdot)\\) be vector space and \\(\\vec{x},\\vec{y}\\in\\mathbb{R}^{n}\\), then the inner product of a two vectors \\(\\vec{x}\\) and \\(\\vec{y}\\) are defined as \\(\\langle\\cdot,\\cdot\\rangle\\colon\\mathbb{R}^{n}\\times\\mathbb{R}^{n}\\to\\mathbb{R}\\) s.t.\n\\[\n(\\vec{x},\\vec{y})\\mapsto\\langle\\vec{x},\\vec{y}\\rangle\\coloneqq\\sum_{i=1}^{n}x_{i}y_{i}=x_{1}y_{1}+x_{2}y_{2}+\\cdots+x_{n}y_{n}\n\\tag{13}\\]\n\n\nLemma 2 Suppose that \\((\\mathbb{R}^{n},+,\\cdot)\\) be vector space and the following map \\(\\langle\\cdot,\\cdot\\rangle\\colon\\mathbb{R}^{n}\\times\\mathbb{R}^{n}\\to\\mathbb{R}\\) is the inner product of 2 vectors, let \\(\\vec{x},\\vec{y},\\vec{z}\\in\\mathbb{R}^{n}\\) and \\(\\lambda,\\mu\\in\\mathbb{R}\\). Then, the following properties hold.\n\n(1). \\(\\langle\\vec{x},\\vec{x}\\rangle\\geq0\\)  (2). \\(\\langle\\vec{x},\\vec{x}\\rangle=0\\Leftrightarrow\\vec{x}=\\vec{0}\\)  (3). \\(\\langle\\vec{x},\\vec{y}\\rangle=\\langle\\vec{y},\\vec{x}\\rangle\\)  (4). \\(\\langle\\vec{x}+\\vec{y},\\vec{z}\\rangle=\\langle\\vec{x},\\vec{z}\\rangle+\\langle\\vec{y},\\vec{z}\\rangle\\)  (5). \\(\\langle\\vec{x},\\vec{y}+\\vec{z}\\rangle=\\langle\\vec{x},\\vec{y}\\rangle+\\langle\\vec{x},\\vec{z}\\rangle\\)  (6). \\(\\langle\\lambda\\vec{x},\\mu\\vec{y}\\rangle=\\lambda\\mu\\langle\\vec{x},\\vec{y}\\rangle\\)\n\n\n\nProof. We prove all 3 properties by using the definition of the inner product itself.\n\n(1). Observe that \\(\\forall x\\in\\mathbb{R}\\colon x^{2}\\geq0\\) and \\(x=0\\Leftrightarrow x^{2}=0\\). If \\(\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})^{\\top}\\) s.t. \\(x_{i}\\in\\mathbb{R}\\) for \\(i=1,2,\\ldots,n\\), then\n\\[\n\\begin{align}\n\\langle\\vec{x},\\vec{x}\\rangle&=\\sum_{i=1}^{n}x_{i}^{2}\\geq0 \\\\\n\\therefore\\langle\\vec{x},\\vec{x}\\rangle &\\geq0\n\\end{align}\n\\]\n(2). Special case in (1) is \\(x=0\\Leftrightarrow x^{2}=0\\), let \\(\\langle\\vec{x},\\vec{x}\\rangle=0\\), then\n\\[\n\\begin{align}\n\\langle\\vec{x},\\vec{x}\\rangle &= 0 \\\\\n&=  0^{2} \\\\\n&= n0^{2} \\\\\n&=\\sum_{i=1}^{n}0^{2} \\\\\n&=  0^{2}+0^{2}+\\cdots+0^{2} \\\\\n\\langle\\vec{x},\\vec{x}\\rangle &= 0\\times0+0\\times0+\\cdots+0\\times0 \\\\\n\\Leftrightarrow\\vec{x} &= \\vec{0} \\\\\n\\therefore\\langle\\vec{x},\\vec{x}\\rangle &=0 \\Leftrightarrow\\vec{x}=\\vec{0}\n\\end{align}\n\\]\n(3). Let \\(\\vec{x},\\vec{y}\\in\\mathbb{R}^{n}\\), then\n\\[\n\\begin{align}\n\\langle\\vec{x},\\vec{y}\\rangle&=\\sum_{i=1}^{n}x_{i}y_{i} \\\\\n&=\\sum_{i=1}^{n}y_{i}x_{i} \\\\\n\\langle\\vec{x},\\vec{y}\\rangle&=\\langle\\vec{y},\\vec{x}\\rangle\n\\end{align}\n\\]\n(4). Observe that \\[\n\\begin{align}\n\\langle\\vec{x}+\\vec{y},\\vec{z}\\rangle &= \\sum_{i=1}^{n}(x_{i}+y_{i})z_{i} \\\\\n&= \\sum_{i=1}^{n}(x_{i}z_{i}+y_{i}z_{i}) \\\\\n&= \\sum_{i=1}^{n}x_{i}z_{i}+\\sum_{i=1}^{n}y_{i}z_{i} \\\\\n\\langle\\vec{x}+\\vec{y},\\vec{z}\\rangle &= \\langle\\vec{x},\\vec{z}\\rangle+\\langle\\vec{y},\\vec{z}\\rangle\n\\end{align}\n\\]\n(5). By definition of the inner product and the pointwise addition of 2 vectors, observe that \\[\n\\begin{align}\n\\langle\\vec{x},\\vec{y}+\\vec{z}\\rangle &= \\sum_{i=1}^{n}x_{i}(y_{i}+z_{i}) \\\\\n&= \\sum_{i=1}^{n}(x_{i}y_{i}+x_{i}z_{i}) \\\\\n&= \\sum_{i=1}^{n}x_{i}y_{i}+\\sum_{i=1}^{n}x_{i}z_{i} \\\\\n\\langle\\vec{x},\\vec{y}+\\vec{z}\\rangle &= \\langle\\vec{x},\\vec{y}\\rangle+\\langle\\vec{x},\\vec{z}\\rangle\n\\end{align}\n\\]\n(6). By definition of the inner product and the s-multiplication, observe that \\[\n\\begin{align}\n\\langle\\lambda\\vec{x},\\mu\\vec{y}\\rangle &= \\sum_{i=1}^{n}(\\lambda x_{i})(\\mu y_{i}) \\\\\n&= \\sum_{i=1}^{n}(\\lambda\\mu)(x_{i}y_{i}) \\\\\n&= \\lambda\\mu\\sum_{i=1}^{n}x_{i}y_{i} \\\\\n\\langle\\lambda\\vec{x},\\mu\\vec{y}\\rangle &= \\lambda\\mu\\langle\\vec{x},\\vec{y}\\rangle\n\\end{align}\n\\]\n\n\n\\(\\square\\)\n\n\n\nCorollary 1 The inner product \\(\\langle\\cdot,\\cdot\\rangle\\) is linear.\n\n\nProof. Immidiete.\n\n\\(\\square\\)\n\n\n\nTheorem 1 Let \\(\\vec{x},\\vec{y}\\in\\mathbb{R}^n\\) and \\(\\lambda,\\mu\\in\\mathbb{R}\\setminus{\\{0\\}},\\) then the inner product of \\(\\vec{x}\\) and \\(\\vec{y}\\) can be computed as follow\n\\[\n\\langle\\vec{x},\\vec{y}\\rangle\\coloneqq\\lambda\\mu\\left\\langle \\frac{1}{\\lambda}\\vec{x},\\frac{1}{\\mu}\\vec{y}\\right\\rangle\n\\tag{14}\\]\n\n\nProof. From Lemma¬†2, we see that for \\(\\vec{x},\\vec{y}\\in\\mathbb{R}^n\\) and \\(\\lambda,\\mu\\in\\mathbb{R}\\setminus{\\{0\\}}\\),\n\\[\n\\begin{align}\n\\left\\langle\\frac{1}{\\lambda}\\vec{x},\\frac{1}{\\mu}\\vec{y}\\right\\rangle &= \\frac{1}{\\lambda}\\frac{1}{\\mu}\\langle\\vec{x},\\vec{y}\\rangle \\\\\n\\Leftrightarrow \\lambda\\mu\\left\\langle\\frac{1}{\\lambda}\\vec{x},\\frac{1}{\\mu}\\vec{y}\\right\\rangle &= \\lambda\\mu\\frac{1}{\\lambda}\\frac{1}{\\mu}\\langle\\vec{x},\\vec{y}\\rangle \\\\\n\\lambda\\mu\\left\\langle\\frac{1}{\\lambda}\\vec{x},\\frac{1}{\\mu}\\vec{y}\\right\\rangle &=\\langle\\vec{x},\\vec{y}\\rangle\n\\end{align}\n\\]\n\n\\(\\square\\)\n\n\n\\(\\quad\\) We compute the inner product \\(\\langle\\vec{x},\\vec{y}\\rangle\\) by using Theorem¬†1 instead of using the Definition¬†7. Theoritically, there is nothing wrong in computing the inner product by using the definition as it is. Nevertheless, when we compute it by using programming language, we have to declare what data type shall we use, and each datatype has their own boundary (a.k.a. ‚Äúbottleneck‚Äù).\n\\(\\quad\\) For example, suppose that we want to do numerical computation by using C++ programming language, and in our code, we declare variable double sc. Now, sc is a variable in C++ having double as its datatype, then the limits of sc \\(\\textemdash\\) the max or min value that sc can store \\(\\textemdash\\) can be known by using the limits header as follows.\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main(void) {\n    double min_limits = std::numeric_limits&lt;double&gt;::min();\n    double max_limits = std::numeric_limits&lt;double&gt;::max();\n    std::cout &lt;&lt; min_limits &lt;&lt; \"&lt;= x &lt;=\" &lt;&lt; max_limits;\n}\nby compiling and execute the program above, it yields (in our machine)\n\\[\n\\texttt{2.22507e-308 &lt;= x &lt;= 1.79769e+308}\n\\]\nNow, in theoritical perspective, let \\(x=1.79769\\times10^{308}\\), then add \\(x\\) by \\(x\\) itself, we should have that \\(x+x=2x=(2\\times1.79769)\\times10^{308}=3.59538\\times10^{308}\\). But, it is not so when we have the following code\nstd::cout &lt;&lt; max_limits + max_limits &lt;&lt; '\\n';\nwhich yields inf (infinity, \\(\\infty\\)), and this is one of undesired behaviour and numerical issue that we have to handle.\n\\(\\quad\\) In order to avoid undesired behaviour and numerical issue when computing the inner product of 2 vectors, say \\(\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})^{\\top}\\) and \\(\\vec{y}=(y_{1},y_{2},\\ldots,y_{n})^{\\top}\\), we use Theorem¬†1 by choosing \\(\\lambda,\\mu\\in\\mathbb{R}\\) s.t.\n\\[\n\\lambda\\coloneqq\\max\\left\\{ \\vert x_{1}\\vert,\\vert x_{2}\\vert,\\ldots,\\vert x_{n}|\\colon\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})^{\\top}\\right\\}\n\\tag{15}\\] \\[\n\\mu\\coloneqq\\max\\left\\{ \\vert y_{1}\\vert,\\vert y_{2}\\vert,\\ldots,\\vert y_{n}\\vert\\colon\\vec{y}=(y_{1},y_{2},\\ldots,y_{n})^{\\top}\\right\\}\n\\tag{16}\\]\nif \\(\\lambda=0\\) or \\(\\mu=0\\), then \\(\\lambda=\\varepsilon\\) or \\(\\mu=\\varepsilon\\) for \\(0&lt;\\varepsilon\\ll1\\) in order to avoid division by \\(0\\). In other words, we try to seek the absolute maximum elements1 of \\(\\vec{x}\\) and \\(\\vec{y}\\), if it is found that \\(0\\) is the absolute maximum elements of \\(\\vec{x}\\) or \\(\\vec{y}\\), then we replace \\(0\\) by \\(\\varepsilon\\). After that, we compute their s-multiplication, \\((1/\\lambda)\\vec{x}\\) and \\((1/\\mu)\\vec{y}\\), and then compute their inner product \\(\\langle(1/\\lambda)\\vec{x},(1/\\mu)\\vec{y}\\rangle\\). Finally, we multiply it back by \\(\\lambda\\mu\\) so we have computed \\(\\langle\\vec{x},\\vec{y}\\rangle\\). The following is the algorithm we use to compute \\(\\langle\\vec{x},\\vec{y}\\rangle\\).\n    \\begin{algorithm}\n    \\caption{The inner product, $\\langle\\cdot,\\cdot\\rangle\\colon\\mathbb{R}^{n}\\times\\mathbb{R}^{n}\\to\\mathbb{R}$}\n    \\begin{algorithmic}\n    \\STATE Define $\\vec{x},\\vec{y}\\in\\mathbb{R}^{n}$ s.t. $\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})^{\\top}$ and $\\vec{y}=(y_{1},y_{2},\\ldots,y_{n})^{\\top}$\n    \\STATE Let $\\lambda,\\mu\\in\\mathbb{R}$ s.t. $\\lambda,\\mu$ are defined by using equation $(18)$ and $(19)$, respectively.\n    \\STATE $\\textbf{if } \\lambda = 0 \\textbf{ then } \\lambda\\longleftarrow\\varepsilon$\n    \\STATE $\\textbf{if } \\mu = 0 \\textbf{ then }\\mu\\longleftarrow\\varepsilon$\n    \\STATE Let $\\vec{a},\\vec{b},\\vec{c}\\in\\mathbb{R}^{n}$\n    \\STATE $\\vec{a}\\longleftarrow(1/\\lambda)\\vec{x}$\n    \\STATE $\\vec{b}\\longleftarrow(1/\\mu)\\vec{y}$\n    \\STATE $\\vec{c}\\longleftarrow\\vec{a}\\ast\\vec{b}\\qquad$ \\COMMENT{pointwise multiplication of 2 vectors}\n    \\STATE $\\langle\\vec{x},\\vec{y}\\rangle\\longleftarrow\\lambda\\mu\\text{ sum}(\\vec{c})\\qquad$ \\COMMENT{$\\text{sum}(\\vec{c})$ is computed by using Kahan's sum algorithm}\n    \\RETURN{$\\langle\\vec{x},\\vec{y}\\rangle$}\n    \\end{algorithmic}\n    \\end{algorithm}"
  },
  {
    "objectID": "paper/2024/fsr1/index.html#ell_p-norm-and-euclidean-norm",
    "href": "paper/2024/fsr1/index.html#ell_p-norm-and-euclidean-norm",
    "title": "Linav: Computation of Vectors in Linear Algebra",
    "section": "2.4 \\(\\ell_{p}\\)-norm and Euclidean Norm",
    "text": "2.4 \\(\\ell_{p}\\)-norm and Euclidean Norm\n\n\nDefinition 8 (Solomon, J., 2015) The \\(\\ell_{p}\\)-norm is defined as a function \\(\\|\\cdot\\|_{p}\\colon V\\to[0,\\infty)\\) s.t.\n\\[\n\\forall\\vec{x}\\in V\\colon\\vec{x}\\mapsto\\|\\vec{x}\\|_{p}\\coloneqq\\left(\\sum_{i=1}^{n}\\vert x_{i}\\vert^{p}\\right)^{1/p}\n\\tag{17}\\]\nspecial case of \\(\\ell_{p}\\)-norm is having \\(p=2\\) which is known as the Euclidean norm i.e., \\(\\parallel\\cdot\\parallel_{2}\\colon V\\to[0,\\infty)\\) s.t.\n\\[\n\\forall\\vec{x}\\in V\\colon\\vec{x}\\mapsto\\|\\vec{x}\\|_{2}\\coloneqq\\sqrt{\\sum_{i=1}^{n}x_{i}^{2}}\n\\tag{18}\\]\nor having \\(p=1\\), we have the taxi cab norm\n\\[\n\\forall\\vec{x}\\in V\\colon\\vec{x}\\mapsto\\|\\vec{x}\\|_{1}\\coloneqq\\sum_{i=1}^{n}\\vert x_{i}\\vert\n\\tag{19}\\]\n\n\nLemma 3 \\(\\forall\\vec{x}\\in V \\colon\\forall\\lambda\\in\\mathbb{R}\\colon\\parallel\\lambda\\vec{x}\\parallel_{p} = \\vert\\lambda\\vert\\parallel\\vec{x}\\parallel_{p}\\)\n\n\nProof. By using the definition of s-multiplication and Definition¬†8 (see Equation¬†17), let \\(\\vec{x}\\in V\\) and \\(\\lambda\\in\\mathbb{R}\\), then observe that\n\\[\n\\begin{align}\n\\parallel\\lambda\\vec{x}\\parallel_{p} &= \\left(\\sum_{i=1}^{n}\\vert\\lambda x_{i}\\vert^{p}\\right)^{1/p} \\\\\n&= \\left(\\sum_{i=1}^{n}\\vert\\lambda\\vert^{p}\\vert x_{i}\\vert^{p}\\right)^{1/p} \\\\\n&= \\left(\\vert\\lambda\\vert^{p}\\sum_{i=1}^{n}\\vert x_{i}\\vert^{p}\\right)^{1/p} \\\\\n&= \\left(\\vert\\lambda\\vert^{p}\\right)^{1/ p}\\left(\\sum_{i=1}^{n}\\vert x_{i}\\vert^{p}\\right)^{1/p} \\\\\n&= \\vert\\lambda\\vert^{p/p}\\left(\\sum_{i=1}^{n}\\vert x_{i}\\vert^{p}\\right)^{1/p} \\\\\n&= \\vert\\lambda\\vert\\left(\\sum_{i=1}^{n}\\vert x_{i}\\vert^{p}\\right)^{1/p} \\\\\n\\parallel\\lambda\\vec{x}\\parallel_{p} &= \\vert\\lambda\\vert\\|\\vec{x}\\|_{p}\n\\end{align}\n\\]\n\n\\(\\square\\)\n\n\n\nTheorem 2 Let \\(\\vec{x}\\in V\\) and \\(\\lambda\\in\\mathbb{R}^n\\setminus\\{0\\}\\), then\n\\[\n\\parallel\\vec{x}\\parallel_{p} = \\vert\\lambda\\vert\\left|\\left|\\frac{1}{\\lambda}\\vec{x}\\right|\\right|_{p}\n\\tag{20}\\]\n\n\nProof. From Lemma¬†3, we see that for \\(\\vec{x}\\in V\\) and \\(\\lambda\\in\\mathbb{R}^n\\setminus\\{0\\}\\),\n\\[\n\\begin{align}\n\\left|\\left|\\frac{1}{\\lambda}\\vec{x}\\right|\\right|_{p} &= \\left|\\frac{1}{\\lambda}\\right|\\parallel\\vec{x}\\parallel_{p} \\\\\n\\Leftrightarrow\\vert\\lambda\\vert\\left|\\left|\\frac{1}{\\lambda}\\vec{x}\\right|\\right|_{p} &= \\vert\\lambda\\vert\\left|\\frac{1}{\\lambda}\\right|\\parallel\\vec{x}\\parallel_{p} \\\\\n&= \\vert\\lambda\\vert\\frac{1}{\\vert\\lambda\\vert}\\parallel\\vec{x}\\parallel_{p} \\\\\n\\vert\\lambda\\vert\\left|\\left|\\frac{1}{\\lambda}\\vec{x}\\right|\\right|_{p} &= \\parallel\\vec{x}\\parallel_{p}\n\\end{align}\n\\]\n\n\\(\\square\\)\n\n\n\\(\\quad\\) As always, due to numerical issue, we compute the \\(\\ell_{p}\\)-norm for \\(\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})^{\\top}\\) by using Theorem¬†2 where we choose \\(\\lambda\\in\\mathbb{R}\\) using Equation¬†15. The following Algorithm 3 is algorithm we use to compute it. Once we establish algorithm to compute the \\(\\ell_{p}\\)-norm of a vector, then we compute the Euclidean norm by substitute \\(p=2\\), and \\(p=1\\) for the taxi cab norm.\n    \\begin{algorithm}\n    \\caption{The $\\ell_{p}$-norm, $\\|\\cdot\\|_{p}\\colon\\mathbb{R}^{n}\\to[0,\\infty)$}\n    \\begin{algorithmic}\n    \\STATE Define $\\vec{x}\\in\\mathbb{R}^{n}$ s.t. $\\vec{x}=(x_{1},x_{2},\\ldots,x_{n})^{\\top}$ and $p\\in\\mathbb{R}$\n    \\STATE Let $\\lambda\\in\\mathbb{R}$ s.t. $\\lambda$ is defined by using equation $(18)$\n    \\STATE $\\textbf{if } \\lambda = 0 \\textbf{ then } \\lambda\\longleftarrow\\varepsilon$\n    \\STATE Let $\\vec{a}\\in\\mathbb{R}^{n}$ and $b\\in\\mathbb{R}$\n    \\STATE $\\vec{a}\\longleftarrow(1/\\lambda)\\vec{x}$\n    \\STATE $b\\longleftarrow\\text{sum}(\\text{pow}(\\text{abs}(\\vec{a}),p))\\qquad$ \\COMMENT{$\\text{pow}(\\cdot,\\cdot)$ is computed by using equation (12)}\n    \\STATE $\\|\\vec{x}\\|_{p}\\longleftarrow\\lambda b^{1/p}$\n    \\RETURN{$\\parallel\\vec{x}\\parallel_{p}$}\n    \\end{algorithmic}\n    \\end{algorithm}\n\n\nDefinition 9 From the Euclidean norm we define the Euclidean distance of \\(2\\) vectors, say \\(\\vec{x}\\) and \\(\\vec{y}\\), as a map \\(d\\colon\\mathbb{\\mathbb{R}}^{n}\\times\\mathbb{R}^{n}\\to\\mathbb{R}\\) s.t.\n\\[\n\\forall\\vec{x},\\vec{y}\\in\\mathbb{R}^{n}\\colon(\\vec{x},\\vec{y})\\mapsto d(\\vec{x},\\vec{y})\\coloneqq\\|\\vec{x}-\\vec{y}\\|_{2}\n\\tag{21}\\]\n\n\nDefinition 10 Normal vector \\(\\hat{x}\\in V\\) is a vector which has its Euclidean norm is equal to one, i.e., \\(\\|\\hat{x}\\|_{2}=1\\).\n\n\nTheorem 3 \\(\\forall\\vec{x}\\in\\mathbb{R}^{n}\\setminus\\{\\vec{0}\\}\\colon\\exists\\hat{x}\\in\\mathbb{R}^{n}\\colon\\hat{x}=\\|\\vec{x}\\|_{2}^{-1}\\vec{x}\\Leftrightarrow\\|\\hat{x}\\|_{2}=1\\)\n\n\nProof. Let \\(\\vec{x},\\hat{x}\\in\\mathbb{R}^{n}\\setminus\\{\\vec{0}\\}\\), s.t., \\(\\hat{x}=\\|\\vec{x}\\|_{2}^{-1}\\vec{x}\\), then\n\\[\n\\begin{align}\n\\Leftrightarrow\\|\\hat{x}\\|_{2}&=\\|\\|\\vec{x}\\|_{2}^{-1}\\vec{x}\\|_{2} \\\\\n&=\\vert\\|\\vec{x}\\|_{2}^{-1}\\vert\\|\\vec{x}\\|_{2} \\\\\n&=\\|\\vec{x}\\|_{2}^{-1}\\|\\vec{x}\\|_{2} \\\\\n&=\\|\\vec{x}\\|_{2}^{1-1} \\\\\n&=\\|\\vec{x}\\|_{2}^{0} \\\\\n\\Leftrightarrow\\|\\hat{x}\\|_{2}&=1\n\\end{align}\n\\]\n\n\\(\\square\\)"
  },
  {
    "objectID": "paper/2024/fsr1/index.html#footnotes",
    "href": "paper/2024/fsr1/index.html#footnotes",
    "title": "Linav: Computation of Vectors in Linear Algebra",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe could find it either by using linear search, or by sorting (take the absolute value of the elements first before comparing them) the elements and then return the element of the last index if it is sorted in ascending order, or return the element in the first index if it is sorted in descending order.‚Ü©Ô∏é"
  },
  {
    "objectID": "blog/2024/fsb1/index.html",
    "href": "blog/2024/fsb1/index.html",
    "title": "Memperlakukan std::vector C++ sebagai Vektor Aljabar Linear Dengan Menggunakan linav.h",
    "section": "",
    "text": "Email\n        muhammadrezafahlevi666@gmail.com\n    \n\n\n\n\n\n\nLinav Demo\n\n\nC++ merupakan salah satu bahasa pemrograman favorit bagi mereka yang suka mengkomputasi sesuatu secara manual, dan mereka yang memiliki pemahan yang baik mengetai algoritma. Kecepatan C++ dalam mengeksekusi program membuatnya sesuai untuk menyelesaikan permasalahan optimisasi parameter-rill sulit, yang mana permasalahan ini biasanya dimodelkan ke bentuk vektor aljabar linear.\nC++ memiliki pustaka standar (standard library) yang menyediakan fungsi yang berguna untuk mempermudah suatu komputasi. Fungsi yang disediakan oleh pustaka standar ini dapat digunakan dengan mendeklarasikan header C++. Salah satu header C++ yang berguna ialah vector, yang mana dengan mendeklarasikan #include &lt;vector&gt;, kita dapat mendeklarasikan variable dengan tipe data std::&lt;vector&gt; yang ukurannya tidak tetap.\nMisalnya, jika kita mempunyai kodingan sebagai berikut\n#include &lt;vector&gt;\n\nint main(void) {\n    std::vector&lt;double&gt; v = {2.0, 3.0, 5.0};\n    v.pushback(7.0);\n}\nPada awalnya, v merupakan vektor dengan anggota 2.0, 3.0, 5.0, setelah v.pushback(7.0) maka anggota v ialah 2.0, 3.0, 5.0, 7.0. Akan tetapi, permasalahannya muncul ketika kita mempunya kodingan C++ berikut\nstd::vector&lt;double&gt; u = v + v; // eror\nstd::vector&lt;double&gt; w = 3.5 * u; // ini juga bakalan eror\nJika program ini dikompilasi (compile) dan dieksekusi (execution), maka akan menampilkan pesan eror.\nC++ mempunyai std::linalg yang berguna untuk memudahkan komputasi aljabar linear. Dengan menggunakan std::linalg, kita dapat komputasi penjumlahan titik (pointwise addition) dan multiplikasi-s (s-multiplication), yang mana, operator ini merupakan operator utama dalam vektor aljabar linear.\nMeskipun demikan, memiliki dan mengembangkan header C++ sendiri merupakan latihan yang baik, dan setidaknya dilakukan sekali seumur hidup. Oleh karena itu, kami mengembangkan header C++ linav.h yang berguna untuk memperlakukan std::vector layaknya vektor aljabar linear. Berikut merupakan demonstrasi singkat kegunaan linav.h\n#include \"Linav/linav.h\"\n#include &lt;vector&gt;\nusing namespace std;\nusing namespace anum;\n\nint main(void) {\n    Linav u(vector&lt;double&gt; {2.0, 4.0, 6.0});\n    Linav v(vector&lt;double&gt; {2.0, 3.0, 5.0});\n\n    // ini namanya penjumlahan titik,\n    // kalo bahasa kampungnya pointwise addition\n    Linav w = u + v; // gak bakalan eror;\n\n    // Nah, kalo ini namanya multiplikasi-s,\n    // kalo bahasa kampungnya ini tuh s-multiplication.\n    // kalo masih bingung juga dengan istilahnya, anggap\n    // aja ini perkalian skalar\n    Linav x = 7.5 * w; // ini juga gak bakalan eror; horeyy :D\n\n    // Yang ini tuh namanya fungsi untuk menghitung\n    // jarak aku dan doi jika aku di titik u dan doi\n    // di titik v. Kalo bahasa kampungnya itu Euclidean distance\n    double jarak_uv = distance(u, v);\n\n    // tampilkan hasil komputasinya\n    println(\"Vektor u = \", u);\n    println(\"Vektor v = \", v);\n    println(\"Kalo u ditambah v, w = u + v = \", w);\n    println(\"Kalo 7.5 dikalikan w, 7.5 * w = \", x);\n    println(\"\\nJarak titik u dengan v ialah \", jarak_uv);\n}\nJika kodingan C++ ini dikompilasi dan dieksekusi, maka keluaran dari kodingan ini sebagai berikut\n\n    $\\texttt{Vektor u = (2, 4, 6)}$ \n    $\\texttt{Vektor v = (2, 3, 5)}$ \n    $\\texttt{Kalo u ditambah v, w = u + v = (4, 7, 11)}$ \n    $\\texttt{Kalo 7.5 dikalikan w, 7.5 * w = (30, 52.5, 82.5)}$ \n    $\\texttt{Jarak titik u dengan v ialah 1.41421}$\n\nHal-hal yang sifatnya detail mengenai header C++ linav.h, maka kami sarankan untuk membaca artikel (riset) berikut, Linav: Computation of Vectors in Linear Algebra. Dan untuk mengkonfigurasi header linav.h, dapat dilihat di halaman github Linav kami.\n\n    \n    Hak Cipta\n    Memperlakukan std::vector sebagai Vektor Aljabar Linear Dengan Menggunakan linav.h oleh Muhammad Reza Fahlevi berlisensi di bawah Attribusi-NonKomersial-BerbagiSerupa 4.0 Internasional (Attribution-NonCommercial-ShareAlike 4.0 International)\n    Dukung Fahlevisia\n\n\n    \n    Fahlevisia\n    Repositori Digital Personal\n    Do you like what you have read?You may treat the author a cup of coffee as a form of thank you\n    \n         Treate the author a cup of coffee\n    \n    Fahlevisia is thanked to the honourable reader who support us and/or dedicate some of his/her time reading our article."
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Fahlevisia - Blog",
    "section": "",
    "text": "Berisikan apa yang baru, pendapat, komentar, dan pemikiran kami.\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nGoogle Mengucapkan Selamat atas Pencapaian Fahlevisia\n\n\n\n\n\n\n\nFahlevisia\n\n\nGoogle Search\n\n\n\n\nBentuk apresiasi Google kepada Fahlevisia\n\n\n\n\n\n\nFeb 23, 2024\n\n\nMuhammad Reza Fahlevi, S.Kom. \n\nVerified\n\n\n\n\n\n\n\n\n  \n\n\n\n\nMemperlakukan std::vector C++ sebagai Vektor Aljabar Linear Dengan Menggunakan linav.h\n\n\n\n\n\n\n\nAljabar Linear\n\n\nC++\n\n\nVektor\n\n\n\n\nHeader C++ yang memungkinkan untuk komputasi vektor aljabar linear\n\n\n\n\n\n\nFeb 12, 2024\n\n\nMuhammad Reza Fahlevi, S.Kom. \n\nVerified\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "yth/index.html",
    "href": "yth/index.html",
    "title": "Fahlevisia - Artikel Bpk/Ibu Yth.",
    "section": "",
    "text": "Kegiatan Intervensi Jumlah Anak Stunting di Wilayah Kerja UPT Puskesmas Kuok\n\n\n\n\n\n\n\nStunting\n\n\nTPG\n\n\nTPPS\n\n\nUPT Puskesmas Kuok\n\n\n\n\nDalam Rangka Upaya Menurunkan Angka Anak Stunting Indonesia\n\n\n\n\n\n\nJan 29, 2024\n\n\nYulisa Siregar, Amd.Gz., S.E. \n\nVerified\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "paper/2024/fsr3/index.html#vectors",
    "href": "paper/2024/fsr3/index.html#vectors",
    "title": "The Description of Every Constructors, Functions Member, and Functions of Limav",
    "section": "3.1 Vectors",
    "text": "3.1 Vectors\n\n3.1.1 anum::Vector()\n\nDefault constructor to construct \\((0,0)\\in\\mathbb{R}^2\\).\nE.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector nullvec;\n    anum::println(nullvec);\n}\nOutput:\n(0,0)\n\n\n\n3.1.2 anum::Vector(unsigned int dimension)\n\nConstructor to construct a null vector in \\(\\mathbb{R}^n\\), where \\(n\\coloneqq\\) dimension. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Vector v(3);\n    anum::println(\"vector v is \", v);\n}\nOutput:\nvector v is (0, 0, 0)\n\n\n\n3.1.3 anum::Vector(std::vector&lt;double&gt;)\n\nConstructor to construct \\(\\vec{x}\\in\\mathbb{R}^n\\). E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Vector x (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    anum::println(\"Vector x is \", x);\n}\nOutput:\nVector x is (1, 2, 3)\n\n\n\n3.1.4 double accs(unsigned int ith_position) const\n\nFunction member (method) to get the ith-element/component of a vector in \\(\\mathbb{R}^n\\), that is if \\(\\vec{x}\\in\\mathbb{R}^n\\) s.t. \\(\\vec{x}=(x_1,x_2,\\ldots,x_n)\\), then the 2nd-component of \\(\\vec{x}\\) is \\(x_2\\). E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Vector x (std::vector&lt;double&gt; {2.0, 3.0, 5.0});\n    const anum::Vector y (std::vector&lt;double&gt; {7.0, 11.0, 13.0});\n\n    const double val_x = x.accs(1);\n    const double val_y = y.accs(2);\n\n    anum::println(\"vector x is \", x);\n    anum::println(\"vector y is \", y);\n    anum::println(\"the 2nd-component of x is \", val_x);\n    anum::println(\"the 3rd-component of y is \", val_y);\n}\nOutput:\nvector x is (2, 3, 5)\nvector y is (7, 11, 13)\nthe 2nd-component of x is 3\nthe 3rd-component of y is 13\n\n\n\n3.1.5 void updt(unsigned int ith_position, double new_val)\n\nFunction member (method) to update the ith-component of a vectors in \\(\\mathbb{R}^n\\) by a new real number. That is if \\(\\vec{x}=(x_1,\\ldots, x_{n-1}, x_n)\\) and we change \\(x_{n-1}=x_{n-1}^\\ast\\), then our new \\(\\vec{x}\\) is \\(\\vec{x}=(x_1,\\ldots,x_{n-1}^\\ast,x_n)\\). E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Vector x (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    anum::println(\"Vector x before is \", x);\n    x.updt(1, 7.3);\n    anum::println(\"After update, x is equal to \", x);\n}\nOutput:\nVector x before is (1, 2, 3)\nAfter update, x is equal to (1, 7.3, 3)\n\n\n\n3.1.6 unsigned int get_dim()\n\nFunction member (method) to get the dimension of a vector lies in. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    std::vector&lt;double&gt; v {1.0, 7.0, 5.0, 3.0};\n    anum::Vector v_vec (v);\n    \n    const unsigned int dim_v = v_vec.get_dim();\n    \n    anum::println(\"Vector v_vec is \", v_vec);\n    anum::println(\"dim(v_vec) = \", dim_v);\n}\nOutput:\nVector v_vec is (1, 7, 5, 3)\ndim(v_vec) = 4\n\n\n\n3.1.7 anum::Vector operator +(anum::Vector lhs, anum::Vector rhs)\n\nA binary operator to perform addition of 2 vectors. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector v (std::vector&lt;double&gt; {2.0, 3.0, 5.0});\n    \n    const anum::Vector w = u + v;\n    \n    anum::println(\"Vector u is \", u);\n    anum::println(\"Vector v is \", v);\n    anum::println(\"If w = u + v, then vector w is equal to \", w);\n}\nOutput:\nVector u is (1, 2, 3)\nVector v is (2, 3, 5)\nIf w = u + v, then vector w is equal to (3, 5, 8)\n\n\n\n3.1.8 anum::Vector operator -(anum::Vector lhs, anum::Vector rhs)\n\nA binary operator to perform substraction of 2 vectors. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector v (std::vector&lt;double&gt; {2.0, 3.0, 5.0});\n    \n    const anum::Vector w = u - v;\n    \n    anum::println(\"Vector u is \", u);\n    anum::println(\"Vector v is \", v);\n    anum::println(\"If w = u + v, then vector w is equal to \", w);\n}\nOutput:\nVector u is (1, 2, 3)\nVector v is (2, 3, 5)\nIf w = u - v, then vector w is equal to (-1, -1, -2)\n\n\n\n3.1.9 anum::Vector operator *(anum::Vector, anum::Vector)\n\nA binary operator to do a elementwise multiplication of 2 vectors. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector v (std::vector&lt;double&gt; {2.0, 3.0, 5.0});\n    \n    const anum::Vector w = u * v;\n    \n    anum::println(\"Vector u is \", u);\n    anum::println(\"Vector v is \", v);\n    anum::println(\"If w = u * v, then vector w is equal to \", w);\n}\nOutput:\nVector u is (1, 2, 3)\nVector v is (2, 3, 5)\nIf w = u * v, then vector w is equal to (2, 6, 15)\n\n\n\n3.1.10 anum::Vector operator *(double, anum::Vector)\n\ns-multiplication of a vector by a real number.\n#include \"Limav/limav.h\"\n\nint main(void) {\n     anum::Vector x (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n     const double lambda = 2.0;\n    \n     anum::Vector v = lambda * x;\n    \n     anum::println(\"Vector x is \", x);\n     anum::println(\"If v = 2x, then v vector is \", v);\n}\nOutput:\nVector x is (1, 2, 3)\nIf v = 2x, then v vector is (2, 4, 6)\n\n\n\n3.1.11 anum::Vector operator *(anum::Vector, double)\n\ns-multiplication of vectors by a real number. In this case, if \\(\\lambda\\in\\mathbb{R}\\) and \\(\\vec{x}\\in\\mathbb{R}^n\\), then \\(\\vec{x}\\lambda=\\lambda\\vec{x}\\).\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const double lambda = 3.0;\n    \n    anum::Vector v = u * lambda;\n\n    anum::println(\"u vector is equal to \", u);\n    anum::println(\"If v = 3u, then v is equal to \", v);\n}\nOutput:\nu vector is equal to (1, 2, 3)\nIf v = 3u, then v is equal to (3, 6, 9) \n\n\n\n3.1.12 anum::Vector abs(anum::Vector)\n\nA function to take absolute value for each components of a vectors. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Vector u (std::vector&lt;double&gt; {1.0, -2.3, -3.2});\n    anum::Vector v = abs(u);\n    anum::println(\"u vector is equal to \", u);\n    anum::println(\"If v = abs(u), then v = \", v);\n}\nOutput:\nu vector is equal to (1, -2.3, -3.2)\nIf v = abs(u), then v = (1, 2.3, 3.2)\n\n\n\n3.1.13 double sum(anum::Vector)\n\nTake the sum of component of vector \\(\\vec{x}\\) by using Kahan‚Äôs sum algorithm. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const double usum = sum(u);\n    anum::println(\"u vector is \", u);\n    anum::println(\"sum(u) = \", usum);\n}\nOutput:\nu vector is (1, 2, 3)\nsum(u) = 6\n\n\n\n3.1.14 anum::Vector power(anum::Vector, double)\n\nA function to do elementwise powered by a real number, i.e.¬†power(\\(\\vec{x},\\lambda\\)) \\(\\coloneqq (x_1^\\lambda, x_2^\\lambda,\\ldots,x_n^\\lambda)\\). E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector v = power(u, 2.0);\n    anum::println(\"u vector is equal to \", u);\n    anum::println(\"power(u, 2) = \", v);\n}\nOutput:\nu vector is equal to (1, 2, 3)\npower(u, 2) = (1, 4, 9)\n\n\n\n3.1.15 double lpnorm(anum::Vector, double)\n\nCompute the \\(\\ell_p\\)-norm of a vector, i.e.¬†\\(\\|\\vec{x}\\|_p\\coloneqq(\\sum_i|x_i|^p)^{1/p}\\). E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const double l3norm = lpnorm(u, 3.0);\n    anum::println(\"u vector is \", u);\n    anum::println(\"lpnorm(u, 3) = \", l3norm);\n}\nOutput:\nu vector is (1, 2, 3)\nlpnorm(u, 3) = 3.30193\n\n\n\n3.1.16 eunorm(anum::Vector)\n\nSpecial case of \\(\\ell_p\\)-norm, that is \\(\\ell_2\\), a.k.a. Euclidean norm. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const double ueunorm = eunorm(u);\n    anum::println(\"u vector is equal to \", u);\n    anum::println(\"eunorm(u) = \", ueunorm);\n}\nOutput:\nu vector is equal to (1, 2, 3) \neunorm(u) = 3.74166\n\n\n\n3.1.17 inpro(anum::Vector, anum::Vector)\n\nCompute the inner product \\(\\langle\\cdot,\\cdot\\rangle\\colon\\mathbb{R}^n\\times\\mathbb{R}^n\\to\\mathbb{R}\\) s.t. \\(\\langle\\vec{x},\\vec{y}\\rangle=\\sum_i x_i y_i\\).\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector v (std::vector&lt;double&gt; {3.0, 5.0, 7.0});\n\n    const double uv_inpro = inpro(u, v);\n\n    anum::println(\"u vector is equal to \", u);\n    anum::println(\"v vector is equal to \", v);\n    anum::println(\"&lt;u,v&gt; = \", uv_inpro);\n}\nOutput:\nu vector is equal to (1, 2, 3) \nv vector is equal to (3, 5, 7) \n&lt;u,v&gt; = 34\n\n\n\n3.1.18 double distance(anum::Vector, anum::Vector)\n\nCompute the Euclidean distance of 2 vectors, i.e. \\[\nd(\\vec{x},\\vec{y})=\\sqrt{\\sum_i(x_i-y_i)^2}\n\\]\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector v (std::vector&lt;double&gt; {3.0, 5.0, 7.0});\n    \n    const double d_uv = distance(u, v);\n    \n    anum::println(\"u vector is equal to \", u);\n    anum::println(\"v vector is equal to \", v);\n    anum::println(\"d(u,v) = \", d_uv);\n}\nOutput:\nu vector is equal to (1, 2, 3) \nv vector is equal to (3, 5, 7) \nd(u,v) = 5.38516\n\n\n\n3.1.19 anum::Vector normalize(anum::Vector)\n\nCompute the normal vector of \\(\\vec{x}\\), so we have normal vector \\(\\hat{x}\\) from vector \\(\\vec{x}\\) s.t. \\(\\|\\hat{x}\\|_2=1\\)\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector u (std::vector&lt;double&gt; {3.0, 5.0, 7.0});\n    const anum::Vector u_hat = normalize(u);\n    const double u_l2norm = eunorm(u);\n    const double uhat_l2norm = eunorm(u_hat);\n    anum::print(\"u vector is \", u);\n    anum::println(\" =&gt; lpnorm(u, 2) = \", u_l2norm);\n    anum::print(\"u normalize vector is \", u_hat);\n    anum::println(\" =&gt; lpnorm(u_hat, 2) = \", uhat_l2norm);\n}\nOutput:\nu vector is (3, 5, 7) =&gt; lpnorm(u, 2) = 9.11043\nu normalize vector is (0.329293, 0.548821, 0.76835) =&gt; lpnorm(u_hat, 2) = 1"
  },
  {
    "objectID": "paper/2024/fsr3/index.html#matrix",
    "href": "paper/2024/fsr3/index.html#matrix",
    "title": "The Description of Every Constructors, Functions Member, and Functions of Limav",
    "section": "3.2 Matrix",
    "text": "3.2 Matrix\n\n3.2.1 anum::Matrix(std::vector&lt;double&gt;, unsigned int m_row, unsigned int n_col)\n\nA constructor to construct a \\(m\\times n\\) matrix, \\(A=(a_{ij})\\). E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        1.0, 2.0, 3.0,\n        4.0, 5.0, 6.0,\n        7.0, 8.0, 9.0\n    }, 3, 3);\n    anum::println(\"A matrix is\", A);\n}\nOutput:\nA matrix is\n1 2 3\n4 5 6\n7 8 9\n\n\n\n3.2.2 unsigned int row()\n\nFunction member (method) of anum::Matrix object to get the number of row of a matrix. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Matrix A (std::vector&lt;double&gt; {\n        1.0, 2.0, 3.0,\n        4.0, 5.0, 6.0,\n        7.0, 8.0, 9.0\n    }, 3, 3);\n    const unsigned int Amrow = A.row();\n    anum::println(\"A matrix is\", A);\n    anum::println(\"mrow(A) = \", Amrow);\n}\nOutput:\nA matrix is\n1 2 3\n4 5 6\n7 8 9\nmrow(A) = 3\n\n\n\n3.2.3 unsigned int col()\n\nFunction member (method) of anum::Matrix object to get the number of column of a matrix. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Matrix A (std::vector&lt;double&gt; {\n        1.0, 2.0, 3.0,\n        4.0, 5.0, 6.0,\n        7.0, 8.0, 9.0\n    }, 3, 3);\n    const unsigned int Ancolumn = A.col();\n    anum::println(\"A matrix is \", A);\n    anum::println(\"ncol(A) = \", Ancolumn);\n}\nOutput:\nA matrix is\n1 2 3\n4 5 6\n7 8 9\nncol(A) = 3\n\n\n\n3.2.4 double accs(unsigned int ith_row, unsigned int jth_col)\n\nA function member (method) of anum::Matrix class to get element of a matrix at \\(i\\)th-row and \\(j\\)th-column. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const double a_12 = A.accs(1, 2);\n    anum::println(\"A matrix is \", A);\n    anum::println(\"a_12 of A matrix is (start count from 0) \", a_12);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \na_12 of A matrix is (start count from 0) 13\n\n\n\n3.2.5 void updt(double val, unsigned int ith_row, unsigned int jth_col)\n\nUpdate the element of a matrix at \\(i\\)th-row and \\(jth\\) column by a new real number. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const double myval = 12.0;\n    anum::println(\"A matrix is\", A);\n    A.updt(myval, 1, 1);\n    anum::println(\"A matrix after a_11 = 12.0 is \", A);\n}\nOutput:\nA matrix is\n2 3 5 \n7 11 13 \n17 19 27 \nA matrix after a_11 = 12.0 is \n2 3 5 \n7 12 13 \n17 19 27\n\n\n\n3.2.6 anum::Matrix t(anum::Matrix)\n\nCompute the transpose of a matrix. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Matrix Atranspose = t(A);\n    anum::println(\"A matrix is \", A);\n    anum::println(\"A transpose is \", Atranspose);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \nA transpose is \n2 7 17 \n3 11 19 \n5 13 27\n\n\n\n3.2.7 anum::Matrix operator +(anum::Matrix lhs, anum::Matrix rhs)\n\nCompute the addition of 2 Matrix.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Matrix B (std::vector&lt;double&gt; {\n        1.0, 2.0, 3.0,\n        4.0, 5.0, 6.0,\n        7.0, 8.0, 9.0\n    }, 3, 3);\n    \n    const anum::Matrix C = A + B;\n    \n    anum::println(\"A matrix is \", A);\n    anum::println(\"B matrix is \", B);\n    anum::println(\"If C = A + B, then matrix C is \", C);\n}\nOutput\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \nB matrix is \n1 2 3 \n4 5 6 \n7 8 9 \nIf C = A + B, then matrix C is \n3 5 8 \n11 16 19 \n24 27 36 \n\n\n\n3.2.8 anum::Matrix operator -(anum::Matrix lhs, anum::Matrix rhs)\n\nCompute the substraction of 2 Matrix.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Matrix B (std::vector&lt;double&gt; {\n        1.0, 2.0, 3.0,\n        4.0, 5.0, 6.0,\n        7.0, 8.0, 9.0\n    }, 3, 3);\n    \n    const anum::Matrix C = A - B;\n    \n    anum::println(\"A matrix is \", A);\n    anum::println(\"B matrix is \", B);\n    anum::println(\"If C = A + B, then matrix C is \", C);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \nB matrix is \n1 2 3 \n4 5 6 \n7 8 9 \nIf C = A - B, then matrix C is \n1 1 2 \n3 6 7 \n10 11 18\n\n\n\n3.2.9 anum::Matrix operator *(double sc, anum::Matrix)\n\nA binary operator to scale a matrix by a real number.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Matrix B = 2.0 * A;\n    anum::println(\"A matrix is \", A);\n    anum::println(\"If B = 2A, then B matrix is \", B);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \nIf B = 2A, then B matrix is \n4 6 10 \n14 22 26 \n34 38 54"
  },
  {
    "objectID": "paper/2024/fsr3/index.html#vectors-and-matrix",
    "href": "paper/2024/fsr3/index.html#vectors-and-matrix",
    "title": "The Description of Every Constructors, Functions Member, and Functions of Limav",
    "section": "3.3 Vectors and Matrix",
    "text": "3.3 Vectors and Matrix\n\n3.3.1 anum::Vector get_rowel(anum::Matrix, unsigned int ith_row)\n\nA function member to get all entries of a matrix at \\(i\\)th-row and return it as a anum::Vector object. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Vector v = get_rowel(A, 2);\n    anum::println(\"A matrix is \", A);\n    anum::println(\"the 3rd row elements of A matrix is \", v);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \nthe 3rd row elements of A matrix is (17, 19, 27) \n\n\n\n3.3.2 anum::Vector get_colel(anum::Matrix, unsigned int jth_colel)\n\nA function member to get all entries of matrix at the jth-column, and return it as a anum::Vector object. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Vector v = get_colel(A, 2);\n    anum::println(\"A matrix is \", A);\n    anum::println(\"the 3rd column elements of A matrix is \", v);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \nthe 3rd column elements of A matrix is (5, 13, 27)\n\n\n\n3.3.3 anum::Matrix operator *(anum::Matrix, anum::Matrix)\n\nA binary operator to perform matrix multiplication. E.g.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Matrix B (std::vector&lt;double&gt; {\n        1.0, 2.0, 3.0,\n        4.0, 5.0, 6.0,\n        7.0, 8.0, 9.0\n    }, 3, 3);\n    \n    const anum::Matrix C = A * B;\n    \n    anum::println(\"A matrix is \", A);\n    anum::println(\"\\nB matrix is \", B);\n    anum::println(\"\\nIf C = AB, then C matrix is \", C);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \n\nB matrix is \n1 2 3 \n4 5 6 \n7 8 9 \n\nIf C = AB, then C matrix is \n49 59 69 \n142 173 204 \n282 345 408 \n\n\n\n3.3.4 anum::Vector operator *(anum::Matrix, anum::Vector)\n\nA binary operator to perform multiplication of matrix and vectors, and return it as a anum::Vector object.\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Vector x (std::vector&lt;double&gt; {7.0, 11.0, 13.0});\n    \n    const anum::Vector y = A * x;\n    \n    anum::println(\"A matrix is \", A);\n    anum::println(\"x vector is \", x);\n    anum::println(\"If Ax = y, then y vector is \", y);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \nx vector is (7, 11, 13) \nIf Ax = y, then y vector is (112, 339, 679)\n\n\n\n3.3.5 anum::Matrix t(anum::Vector)\n\nTranspose for a vector will return it as a row matrix.\nint main(void) {\n    const anum::Vector x (std::vector&lt;double&gt; {2.0, 3.0, 5.0});\n    const anum::Matrix xt = t(x);\n    anum::println(\"x vector is \", x);\n    anum::println(\"t(x) is \", xt);\n}\nOutput:\nx vector is (2, 3, 5) \nt(x) is \n2 3 5\n\n\n\n3.3.6 double trace(anum::Matrix)\n\nReturn the sum of the diagonal element of a matrix\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const double disum = trace(A);\n    anum::println(\"A matrix is \", A);\n    anum::println(\"tr(A) = \", disum);\n}\nOutput:\nA matrix is \n2 3 5 \n7 11 13 \n17 19 27 \ntr(A) = 40"
  },
  {
    "objectID": "paper/2024/fsr3/index.html",
    "href": "paper/2024/fsr3/index.html",
    "title": "The Description of Every Constructors, Functions Member, and Functions of Limav",
    "section": "",
    "text": "Email\n        muhammadrezafahlevi666@gmail.com"
  },
  {
    "objectID": "paper/2024/fsr3/index.html#in-linux-operating-system",
    "href": "paper/2024/fsr3/index.html#in-linux-operating-system",
    "title": "The Description of Every Constructors, Functions Member, and Functions of Limav",
    "section": "2.1 In Linux Operating System",
    "text": "2.1 In Linux Operating System\n\nRequirements:\n\\(1\\). C++ compiler. In our case, we use g++.\n\\(2\\). A text editor. In our case, we use vim text editor.\n\\(3\\). Our Limav‚Äôs directory.\n\\(4\\). As always, a terminal.\nSteps to install and use limav.h:\n\\(1\\). Create a new folder having your purpose as the name of this folder. For example, eglimav\n\\(2\\). Copy Limav‚Äôs directory in this new folder.\n\\(3\\). In this new folder, create 2 new bash script (.sh). The first name of the bash script is compfile.sh which is stand for compile file and the second name of the bash script is compandrun.sh which is stand for compile file and run the program. In our example, in our eglimav, we should have compfile.sh and compandrun.sh.\n\\(4\\). Open compfile.sh by using a text editor, and copy and paste this bash script\n#!/bin/bash\necho \"g++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp\" $1 \"-static-libgcc -std=c++14 -o\" $2 \"-O2 --time\";\ng++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp $1 -static-libgcc -std=c++14 -o $2 -O2 --time;\nafter that save it and you may close compfile.sh.\n\\(5\\). Open compandrun.sh by using a text editor, copy and paste the following bash script.\n#!/bin/bash\necho \"g++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp\" $1 \"-static-libgcc -std=c++14 -o\" $2 \"-O2\";\ng++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp $1 -static-libgcc -std=c++14 -o $2 -O2;\n./$2;\nafter that save it and you may close compandrun.sh.\n\\(6\\). Create your main .cpp file, and your .cpp file should look something like this\n#include \"Limav/limav.h\"\n\nint main(void) {\n    // TODO...\n}\nFor example, our main program name is mainprog.cpp, and we have the following C++ code\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector x (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector y (std::vector&lt;double&gt; {4.0, 5.0, 6.0});\n    \n    const anum::Vector z = x + y;\n\n    anum::println(\"Vector x = \", x);\n    anum::println(\"Vector y = \", y);\n    anum::println(\"If vector z = x + y, then vector z = \", z);\n}\nand then save it (see Figure 1).\n\n\n    Figure 1: Our example eglimav in vim text editor.\n\n\\(7\\). Open terminal and change directory to your new folder that you just create. In our example, we change directory into eglimav directory.\n\\(8\\). Before we compile and/or run our C++ program, type the following command and then press enter\nchmod +x compfile.sh compandrun.sh\nwe do this only once.\n\\(9\\). After that, if you want to compile your C++ program, then execute compfile.sh as follows\n./compfile.sh your_cpp.cpp your_cpp\nFor example, if we want to compile our mainprog.cpp program, then we execute compfile.sh as follows\n./compfile.sh mainprog.cpp mainprog\nand the output should be (see Figure 2):\n\ng++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp mainprog.cpp -static-libgcc -std=c++14 -o mainprog -O2 --time\n# cc1plus 0.55 0.08\n# cc1plus 0.43 0.06\n# as 0.01 0.01\n# cc1plus 0.77 0.06\n# as 0.01 0.00\n# cc1plus 0.51 0.04\n# as 0.01 0.01\n# cc1plus 0.54 0.07\n# cc1plus 0.52 0.04\n# as 0.01 0.00\n# cc1plus 0.56 0.04\n# as 0.01 0.00\n# cc1plus 0.36 0.05\n# as 0.00 0.00\n# cc1plus 0.54 0.08\n# cc1plus 0.60 0.04\n# as 0.01 0.00\n# cc1plus 0.36 0.04\n# as 0.00 0.00\n# collect2 0.08 0.02\n\n\n\n    Figure 2: Compile mainprog.cpp via compfile.sh\n\n\\(10\\). If we want to compile and run the program, then execute compandrun.sh as follows\n./compandrun.sh your_cpp.cpp your_cpp\nFor example, if we want to compile and execute mainprog.cpp, then we execute compandrun.sh as follows\n./compandrun.sh mainprog.cpp mainprog\nand we should have the following output of our mainprog.cpp program (see Figure 3):\n g++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp mainprog.cpp -static-libgcc -std=c++14 -o mainprog -O2 Vector x = (1, 2, 3)  Vector y = (4, 5, 6)  If vector z = x + y, then vector z = (5, 7, 9) \n\n\n    Figure 3: Compile and run mainprog.cpp via compandrun.sh\n\nCongratulation. You have installed and use limav.h.\n\n\nRemark. For steps no. \\(1\\) to \\(8\\) show how to install limav.h. For step no. \\(9\\) is how you compile your program, and step no. \\(10\\) is how you compile and run your program."
  },
  {
    "objectID": "paper/2024/fsr3/index.html#steps",
    "href": "paper/2024/fsr3/index.html#steps",
    "title": "The Description of Every Constructors, Functions Member, and Functions of Limav",
    "section": "2.2 steps",
    "text": "2.2 steps\nIn steps 8, you have installed limav.h. For step no. \\(9\\) is how you compile your program, and step no. \\(10\\) is how you compile and run your program."
  },
  {
    "objectID": "paper/2024/fsr3/index.html#in-windows-operating-system",
    "href": "paper/2024/fsr3/index.html#in-windows-operating-system",
    "title": "The Description of Every Constructors, Functions Member, and Functions of Limav",
    "section": "2.2 In Windows Operating System",
    "text": "2.2 In Windows Operating System\n\n2.2.1 Manually\n\nRequirements:\n\\(1\\). C++ compiler. In our case, we use g++.\n\\(2\\). Limav‚Äôs directory.\n\\(3\\). Command prompt.\n\\(4\\). A text editor.\nSteps:\n\\(1\\). Create a new folder having your purpose as the name of this folder. For example, eglimav\n\\(2\\). Copy Limav‚Äôs directory in this new folder.\n\\(3\\). In this new folder, create 2 new batch script (.bat). The first name of the batch script is compfile.bat which is stand for compile file and the second name of the batch script is compandrun.bat which is stand for compile file and run the program. In our example, in our eglimav, we should have compfile.bat and compandrun.bat.\n\\(4\\). Open compfile.bat by using a text editor, and copy and paste this bash script\n@echo off\necho g++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp %1 -static-libgcc -std=c++14 -o %2 -O2\ng++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp %1 -static-libgcc -std=c++14 -o %2 -O2\nafter that save it and you may close compfile.bat.\n\\(5\\). Open compandrun.bat by using a text editor, copy and paste the following batch script.\n@echo off\necho g++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp %1 -static-libgcc -std=c++14 -o %2 -O2\ng++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp %1 -static-libgcc -std=c++14 -o %2 -O2\n%2\nafter that save it and you may close compandrun.bat.\n\\(6\\). Create your main .cpp file, and your .cpp file should look something like this\n#include \"Limav/limav.h\"\n\nint main(void) {\n    // TODO...\n}\nFor example, our main program name is mainprog.cpp, and we have the following C++ code\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector x (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector y (std::vector&lt;double&gt; {4.0, 5.0, 6.0});\n    \n    const anum::Vector z = x * y;\n\n    anum::println(\"Vector x = \", x);\n    anum::println(\"Vector y = \", y);\n    anum::println(\"If vector z = x * y, then vector z = \", z);\n}\nand then save it (see Figure 4).\n\n\n    Figure 4: Our example eglimav in sublime text editor.\n\n\\(7\\). Open command prompt and change directory to your new folder that you just create. In our example, we change directory into eglimav directory.\n\\(8\\). If we want to compile the .cpp file, then type and press enter the following command\ncompfile.bat your_cpp.cpp your_cpp\nFor example, if we want to compile mainprog.cpp, then we execute compfile.bat as follows\ncompfile.bat mainprog.cpp mainprog\nsee Figure 5 for the output:\n g++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp mainprog.cpp -static-libgcc -std=c++14 -o mainprog -O2 \n\n\n    Figure 5: Compile mainprog.cpp via compfile.bat\n\n\\(9\\). If we want to compile and run the .cpp file, then type and press enter the following command\ncompandrun.bat your.cpp your_cpp\nFor example, if we want to compile and run our mainprog.cpp file, then we execute compandrun.bat as follows\ncompandrun.bat mainprog.cpp mainprog\nOutput (see Figure 5):\n g++ Limav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp mainprog.cpp -static-libgcc -std=c++14 -o mainprog -O2 Vector x = (1, 2, 3)  Vector y = (4, 5, 6)  If vector z = x * y, then vector z = (4, 10, 18) \n\n\n    Figure 5: Compile and run mainprog.cpp via compandrun.bat\n\nCongratulation. You have installed and use limav.h.\n\n\n\n2.2.2 Using Dev-C++ Integrated Development Environment\n\nThe only requirements is Dev-C++ Integrated Development Environment (Dev-C++ IDE) and our Limav‚Äôs directory.\nSteps to use limav.h:\n\\(1\\). Create a new folder having your purpose as the name of this folder. For example, eglimav\n\\(2\\). Copy Limav‚Äôs directory in this new folder.\n\\(3\\). Open your Dev-C++ IDE and create a new .cpp file, your .cpp file should look something like the following code:\n#include \"Limav/limav.h\"\n\nint main(void) {\n    // TODO...\n}\nFor example, our mainprog.cpp code is\n#include \"Limav/limav.h\"\n\nint main(void) {\n    const anum::Vector x (std::vector&lt;double&gt; {1.0, 2.0, 3.0});\n    const anum::Vector y (std::vector&lt;double&gt; {4.0, 5.0, 6.0});\n    \n    const anum::Matrix A (std::vector&lt;double&gt; {\n        2.0, 3.0, 5.0,\n        7.0, 11.0, 13.0,\n        17.0, 19.0, 27.0\n    }, 3, 3);\n    const anum::Matrix B (std::vector&lt;double&gt; {\n        1.0, 2.0, 3.0,\n        4.0, 5.0, 6.0,\n        7.0, 8.0, 9.0\n    }, 3, 3);\n    \n    const anum::Vector z = x * y;\n    const anum::Vector Ax = A * x;\n    const anum::Vector Bx = A * x;\n    const anum::Matrix C = A * B;\n    const anum::Vector Cx = C * x;\n\n    anum::println(\"Vector x = \", x);\n    anum::println(\"Vector y = \", y);\n    anum::println(\"Matrix A is\", A);\n    anum::println(\"Matrix B is\", B);\n    anum::println(\"\\nIf vector z = x * y, then vector z = \", z);\n    anum::println(\"If vector z = Ax, then vector z = \", Ax);\n    anum::println(\"If vector z = Bx, then vector z = \", Bx);\n    anum::println(\"If matrix C = AB, then matrix C is\", C);\n    anum::println(\"If vector z = Cx, then vector z = \", Cx);\n}\nAfter that save it in the new folder that you just create. In our case, we save it to eglimav (see Figure 6).\n\n\n    Figure 6: Our mainprog.cpp in Dev-C++ IDE\n\n\\(4\\). Before we compile our mainprog.cpp, we have to configure the compiler options at tab Tools&gt;Compiler Options‚Ä¶ (see Figure 7)\n\n\n    Figure 7: Setup compiler options.\n\n\\(5\\). Checkbox\n\nAdd the following commands when calling the linker:\n\nand in its textarea copy and paste the following commands:\nLimav/Linav/linav.h Limav/Linav/linav.cpp Limav/Linav/linop.cpp Limav/Linav/printprog.cpp Limav/Linam/linam.h Limav/Linam/linam.cpp Limav/Linam/matop.cpp Limav/Linam/printprog.cpp Limav/limav.h Limav/limav.cpp -static-libgcc -std=c++14\nafter that, click Ok (see Figure 8).\n\n\n    Figure 8: Steps to setup the compiler options.\n\n\\(6\\). Finally, compile or compile and run your mainprog.cpp (see Figure 9 for an example).\n\n\n    Figure 9: Output of mainprog.cpp when it is compiled and run.\n\nCongratulation. You have installed and used limav.h by using Dev-C++ IDE."
  },
  {
    "objectID": "paper/2024/fsr4/index.html",
    "href": "paper/2024/fsr4/index.html",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "",
    "text": "Email\n        muhammadrezafahlevi666@gmail.com"
  },
  {
    "objectID": "paper/2024/fsr4/index.html#bagian-2-tak-semudah-itu-mengartikan-ilmu.",
    "href": "paper/2024/fsr4/index.html#bagian-2-tak-semudah-itu-mengartikan-ilmu.",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "Bagian 2: Tak Semudah Itu Mengartikan Ilmu.",
    "text": "Bagian 2: Tak Semudah Itu Mengartikan Ilmu.\n\n\n\\(^1\\)I\n\nlmu haruslah mengandung kebenaran. Hlm. 12. \\(^2\\)Ilmu adalah sampainya makna ke dalam jiwa. Hlm. 13. \\(^3\\)Pemahaman yang salah akan menghasilkan tindakan yang salah. Hlm. 13. \\(^4\\)Tujuan buku ini ditulis. Hlm. 13. \\(^5\\)Al-Quran & Al-Hadits merupakan inspirasi utama bagi setiap muslim. Hlm. 14. \\(^6\\)Seputar pertanyaan mengenai ilmu yang perlu untuk didiskusikan. Hlm. 15. \\(^7\\)Timbulnya sikap meremehkan ilmu disebabkan kurangnya pemahaman mengenai hakikat ilmu. Hlm.15. \\(^8\\)Mencari nafkah memerlukan ilmu juga. Hlm 17. \\(^9\\)Islam tidak melarang seseorang menuntut ilmu untuk menjadi bekal dalam menjamin kelangsungan hidupnya. Hlm. 17.\n\n\\(^{10}\\)Ajarilah anak-anak mu untuk dapat hidup di masanya, karena mereka[dia] dipersiapkan hidup pada masanya bukan pada masamu.-Sayyidina Ali bin Abi Thalib ra. Hlm. 18.-\n\n\n\\(^{11}\\)Barangsiapa yang dikhendaki Allah (SWT.) kebaikan baginya, Dia memberikan pemahaman kepadanya dalam ilmu Agama.- Sabda Rasulullah SAW. Hlm. 19.-\n\n\\(^{12}\\)Jika mengikuti petunjuk Allah SWT, maka ia tidak akan sesat dan celaka. Jika berpaling dari peringatan, maka baginya penghidupan yang sempit. Dalil. QS. Thaaha[20]:123-124. Hlm. 19."
  },
  {
    "objectID": "paper/2024/fsr4/index.html#bagian-3-ilmu-dan-kehidupan.",
    "href": "paper/2024/fsr4/index.html#bagian-3-ilmu-dan-kehidupan.",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "Bagian 3: Ilmu dan Kehidupan.",
    "text": "Bagian 3: Ilmu dan Kehidupan.\n\n\n\\(^1\\)B\n\nudaya ilmu merupakan unsur inti pembentukan karakter setiap peradaban. Hlm. 23. \\(^2\\)Filsafat ialah cinta kebijaksanaan. Hlm. 26. \\(^3\\)Ajaran Hedonisme ialah ajaran yang mengajarkan kepuasan atau kesenangan manusia merupakan nilai kebaikan yang tertinggi. Hlm 26. \\(^4\\)Paham Humanisme ialah paham yang mendahulukan akal pikiran manusia dan mengesampingkan yang lain untuk menghakimi mana yang ‚Äòbenar‚Äô dan yang ‚Äòtidak benar‚Äô. Hlm. 27. \\(^5\\)Contoh para ilmuwan yang mencela dan menghujat agama:\n\nAgama itu candu.-Karl Marx-\n\n\nAgama adalah ilusi.-Sigmund Freud-\n\n\nTuhan sudah mati.-Friedrich Nietzche-\n\n\nSaya tidak tahu dimana letak peranan Tuhan.-Laplace-\n\nAguste Compte menyatakan bahwa pengetahuan lebih utama dibandingkan pertolongan Tuhan. Hlm. 29-30. \\(^6\\)Akhlak jeleknya JJ. Rosseau dan Jean Paul Sartre. Hlm. 32."
  },
  {
    "objectID": "paper/2024/fsr4/index.html#bagian-4-kekeliruan-mengenai-ilmu",
    "href": "paper/2024/fsr4/index.html#bagian-4-kekeliruan-mengenai-ilmu",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "Bagian 4: Kekeliruan Mengenai ilmu",
    "text": "Bagian 4: Kekeliruan Mengenai ilmu\n\n\n\\(^1\\)A\n\nl-Quran adalah Al-Furqan, artinya pembeda antara yang hak dan yang batil. Hlm. 34. \\(^2\\)Tidak sama orang-orang yang mengetahui dan yang tidak mengetahui. QS. Az-Zumar[30]:9. Hlm. 34. \\(^3\\)Di dalam Islam, kita dapat mengklaim bahwa kita dapat mengetahui kebenaran. Hlm. 35. \\(^4\\)Plato & gurunya, yaitu Socrates, mengecam profesi mengajar yang tujuannya adalah memperoleh imbalan berupa uang, bagi mereka, yang demikian itu adalah perbuatan bermoral rendah. Hlm. 37. \\(^5\\)Kebodohan ada 3 jenis. Pertama, bodoh karena kurang atau ketidaktahuan terhadap sesuatu hal yang seharusnya diketahui. Kedua, bodoh adalah meyakini suatu hal yang salah. Ketiga, bodoh adalah berbuat sesuatu yang sudah diketahui bahwa perbuatan yang dilakukannya itu salah. Hlm. 39. \\(^6\\)Kesalahan dalam pikiran akan menghasilkan kesalahan dalam tindakan. Hlm. 43. \\(^7\\)Al-'ilmu fi ash-shuduur, la fi as-sutuur. Hlm. 44. \\(^8\\)Bisa mengakses sumber informasinya bukan berarti sudah memahaminya. Hlm. 45. \\(^9\\)Menghapal merupakan salah satu metode belajar serius. Hlm. 45. \\(^{10}\\)Keadaan sekarang yang ada pada kebanyakan orang adalah\n\\[\n\\#\\textit{Ilmu}\\sim\\frac{1}{\\#\\textit{informasi}}\n\\]\natau, banyaknya ilmu berbanding terbalik dengan banyaknya informasi yang dimiliki. Hlm. 46.\n\\(^{11}\\)Imam Bukhari diperkirakan hapal 600000 (enam ratus ribu) hadis berikut perawinya. Al-Nisaburi mendiktekan tafsir Al-Quran langsung dari ingatannya. Al-Bawardi, seorang ahli bahasa mendiktekan 30000 (tiga puluh ribu) halaman mengenai masalah linguistik. Abu Bakar bin Al-Anbari mendiktekan 45000 (empat puluh lima ribu) halaman hadis dan mengaku hapal 30 (tiga puluh) buku. Hlm. 46-47. \\(^{12}\\)Dalam Islam, seseorang bisa mengetahui kebenaran. Meskipun demikian, Islam juga memberikan batasan apa yang bisa diketahui oleh seseorang adalah terbatas. Dalilnya, QS. Al-Imran[3]:7. Hlm. 48-49. \\(^{13}\\)Peranan orang yang berkompeten dan orang awam. Hlm. 51. \\(^{14}\\)Menurut Al-Qathan, perbedaan antara ayat-ayat mukhamat dengan mutasyabihat tersebut adalah salah satu dari 3 pengertian. Pengertian pertama, Hlm. 49. Pengertian kedua, Hlm. 50. Pengertian ketiga, Hlm. 51. \\(^{15}\\)Ilmu agama mengkaji ayat qauliyah, sedangkan ilmu umum mempelajari ayat kauniyah. Hlm. 53. \\(^{16}\\)Tujuan mengkajinya adalah untuk semakin mengenal Allah SWT. Hlm. 53. \\(^{17}\\)Yang dimaksud dengan kesatuan ilmu adalah baik ayat qauliyah atau ayat kauniyah, dua-duanya merupakan ayat-ayat Allah SWT. Hlm. 53.\n\n\\(^{18}\\)Ilmu itu adalah cahaya yang Allah (SWT) letakkan ke dalam hati orang beriman.-Imam Malik- Hlm. 53.\n\n\\(^{19}\\)Sesungguhnya yang takut kepada Allah di antara hamba-hamba-Nya adalah ulama (orang-orang yang berilmu). QS. Al-Fatir[35]:28. Hlm 53. \\(^{20}\\)Seiring bertambahnya ilmu, maka semestinya seorang hamba semakin bertakwa kepada Allah SWT . Secara matematis,\n\\[\n\\#\\textit{Ilmu}\\sim\\#\\textit{Ketakwaan}\n\\]\nHlm. 54. \\(^{21}\\)Definisi kemajuan, pembangunan, dan kaitannya dengan ilmu. Hlm 56-57. \\(^{22}\\)Peradaban (yang pernah) maju dalam segi kebendaan. Hlm. 60. \\(^{23}\\)Tujuan hidup mansuia dan kebahagiaan. Hlm. 61. \\(^{24}\\)Paham pembangunan di dalam Islam bersifat ke belakang (de-evolusi). Hlm. 63. \\(^{25}\\)Penyebab kejatuhan dan kebangkrutan suatu masyarakat. Hlm. 61. \\(^{26}\\)Orang yang mengabdi pada dirinya sendiri adalah orang yang sesat. Hlm. 62. \\(^{27}\\)Kemajuan yang hakiki. Hlm. 62."
  },
  {
    "objectID": "paper/2024/fsr4/index.html#bagian-5-pengembangan-ilmu-islami",
    "href": "paper/2024/fsr4/index.html#bagian-5-pengembangan-ilmu-islami",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "Bagian 5: Pengembangan Ilmu Islami",
    "text": "Bagian 5: Pengembangan Ilmu Islami\n\n\n\\(^1\\)S\n\narana yang disediakan Allah bagi manusia untuk memperoleh Ilmu. Hlm. 67. \\(^2\\)Hadis-hadis yang menerangkan seluk-beluk tentang ilmu. Hlm. 68. \\(^3\\)Ulama-ulama yang mengulas konsep ilmu dalam Islam. Hlm. 69-70. \\(^4\\)Rasa kepedulian ilmu seseorang semestinya berbanding lurus dengan seberapa ia mengenal agama Islam. Secara matematis,\n\\[\n\\#\\textit{Peduli Ilmu}\\sim\\#\\textit{Mengenal Agama Islam}\n\\]\nHlm. 70. \\(^5\\)Tempatnya ilmu itu adalah jiwa manusia. Dalilnya, QS. Al-Ankabut[29]:49. Hlm. 71-72. \\(^6\\)Ayat qauliyah dan ayat kauniyah. Hlm. 72-73. \\(^7\\)Tujuan akhir mencari ilmu dalam Islam adalah mengenal Allah SWT. Hlm. 73. \\(^8\\)Manusia memperoleh ilmu dari Allah SWT melalui 4 saluran, yaitu panca indra (al-khawas al-kamsah), akal sehat (al-'aql al-salim), kabar yang benar (al-khabar al-shadiq), dan intuisi (ilham). Hlm. 73-74. \\(^9\\)Paham empirisme. Hlm 75-76. \\(^{10}\\)Pengertian akal sehat. Hlm. 77. \\(^{11}\\)Paham rasionalisme. Hlm 79. \\(^{12}\\)Pengertian intelek. Hlm. 79. \\(^{13}\\)Keterkaitan rasio, intelek, hati, dan akal. Hlm. 80. \\(^{14}\\)Sifat Rasulullah SAW. ada 4. Hlm 89. \\(^{15}\\)Pengertian ilham/intuisi. Hlm. 92. \\(^{16}\\)Ilham itu sangat dekat dengan orang yang terbiasa berpikir. Hlm. 92. $^{17}$3 tingkatan ilmu kita ketahui: konsep (concept), penyimpulan (judgment, tashdiq), dan penalaran (reasoning). Hlm. 95. \\(^{18}\\)Penalaran, analisis. Hlm. 96. \\(^{19}\\)Ilmu itu dikatakan tidak ada batasnya. Dalilnya, QS. Luqman[31]:27. Hlm. 97. \\(^{20}\\)Cara ilmu kita berkembang, yaitu generasi awal mewariskan ilmu kepada generasi berikutnya. Hlm. 97. \\(^{21}\\)Baik amal saleh atau kejahatan, kedua-duanya hanya akan berbalik kepada dirinya sendiri. Dalil, QS. Al-Jaatsiyah[45]:15. Hlm. 99. \\(^{22}\\)Belajar merupakan urusan agama. Bagi siapa saja yang mengerjakannya, maka akan mendapatkan pahala. Dan bagi siapa yang meniggalkannya, maka akan mendapatkan dosa. Hlm. 101. \\(^{23}\\)Khendaknya, pelajarilah ilmu-ilmu yang bermanfaat bagi masing-masing individu. Hlm. 101. \\(^{24}\\)Ilmu yang wajib dituntut ada 2, yaitu ilmu fardhu'ain dan ilmu fardhu kifayah. Hlm. 101-102. \\(^{25}\\)Filsafat, terlebih lagi filsafat barat, bukan ilmu yang baik dipelajari setiap orang. Hlm. 104. \\(^{26}\\)Wara‚Äô artinya berhati-hati agar tidak jatuh kepada yang haram. Qana‚Äôah artinya merasa puas dengan yang ada. Hlm. 107. \\(^{27}\\)Tujulah akhirat dan jangan lupakan pula dunia. Dalilnya, QS. Al-Qashash[28]:77. Hlm. 110. \\(^{28}\\)Membebani kewajiban kepada orang yang tidak tepat merupakan kezaliman. Hlm. 112. \\(^{29}\\)Peranan (fungsi) uang yang diberikan murid ke sang guru. Hlm. 117. \\(^{30}\\)Menurut Al-Ghazali, pendapat guru yang salah masih lebih baik daripada pendapat muridnya yang benar. Hlm. 118. \\(^{31}\\)Kritik yang diberikan untuk sang guru dari sang murid harus dilakukan secara halus. Hlm. 119. \\(^{32}\\)Adab bagi guru. Hlm. 119-120.\n\n\\(^{33}\\)Ilmu itu tidak akan memberikan sebagian darinya sehingga kamu memberikan keseluruhan dirimu. Hlm. 118.\n\n\\(^{34}\\)Salah satu cara untuk fokus belajar. Hlm. 120. \\(^{35}\\)Sesuatu yang mulia tidak dapat disandingkan dengan sesuatu yang hina, kecuali akan menurunkan kemuliannya. Hlm. 123.\n\n\\(^{36}\\)Ilmu itu bukan banyaknya riwayat, tetapi ilmu itu adalah cahaya yang dimasukkan ke dalam hati.-Ibnu Mas'ud, ra.- Hlm. 123.\n\n\\(^{37}\\)Ilmu fardhu'ain, bertujuan untuk membimbing ilmu fardhu kifayah agar berjalan di atas rel yang benar. Hlm. 125. \\(^{38}\\)Mempelajari ilmu fardhu'ain merupakan prioritas pertama dalam belajar. Hlm. 126."
  },
  {
    "objectID": "paper/2024/fsr4/index.html#bagian-6-memaknai-ilmu-cara-islam",
    "href": "paper/2024/fsr4/index.html#bagian-6-memaknai-ilmu-cara-islam",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "Bagian 6: Memaknai Ilmu Cara Islam",
    "text": "Bagian 6: Memaknai Ilmu Cara Islam\n\n\n\\(^1\\)P\n\nrestasi ulama terdahulu, yaitu prestasinya Imam Ath-Thabari, Ibnu Sina, Imam Suyuthi, Imam Al-Ghazali, dan Ibnu Hazm. Hlm. 138. \\(^2\\)Hidup haruslah punya tujuan, sebab tujuan yang menunjuki arah kehidupan. Hlm. 139. \\(^3\\)Allah SWT yang meluaskan dan menyempitkan rezeki. Dalilnya, QS. Ar-Ra'ad[13]:26. Hlm. 142.\n\n\\(^4\\ldots\\)Demikian juga hati, apabila dicegah dari hikmah dan ilmu selama 3 hari, maka hati akan mati.-Fauthul Maushulli- Hlm. 145.\n\n\\(^5\\)Sepandai-pandainya manusia, pasti akan menjadi bodoh ketika ia berhenti belajar. Hlm. 146. \\(^6\\)Masa muda. Hlm. 146. \\(^7\\)Kemauan dan ilmu. Hlm. 149. $^8$2 Golongan yang menentukan umat, yang mana jika 2 golongan ini baik, maka manusianya baik, dan jika 2 golongan buruk, maka buruk manusianya, 2 golongan itu adalah pemerintah dan ulama. Hlm. 157. \\(^9\\)Ciri-ciri ulama su'. Hlm. 157. \\(^{10}\\)Menurut Imam Al-Ghazali di dalam karyanya Kimia Kebahagiaan, terdapat 4 hal yang mesti diketahui manusia untuk bahagia, yaitu, ilmu tentang dirinya, ilmu tentang Tuhannya, ilmu mengenai dunianya, dan ilmu mengenai akhiratnya. Hlm. 161-163.\n\n\\(^{11}\\)Barangsiapa yang berpandangan bahwa menuntut ilmu itu bukanlah jihad, maka sungguh akal dan pikirannya telah mengalami kelemahan.-Abu Darda- Hlm. 165.\n\n\\(^{12}\\)Suri tauladan para ulama, Abu Hurairah, Imam Bukhari, dan Imam Nawawi. Hlm. 166-167. \\(^{13}\\)Kewajiban seorang ahli ilmu adalah menyampaikannya termasuk kepada seorang penguasa zalim. Hlm. 167. \\(^{14}\\)Imam Ahmad menolak mengatakan bahwa Al-Quran itu makhluk. Imam Nawawi lebih memilih terusir dari kota Damaskus daripada mengeluarkan fatwa boleh memungut pajak padahal kekayaan sang Raja cukup untuk membiayai pasukan untuk melawan pasukan Mongol. Sayyid Quthab memilih mati di tiang gantung daripada berkompromi dengan diktator.Buya Hamka menolak seikere. Hlm. 168. \\(^{15}\\)Kesempurnaan ilmu pada diri seseorang adalah apabila dia mengamalkannya dan mengajarkannya kepada orang lain. Hlm. 168. \\(^{16}\\)Dalil berilmu dulu baru berbuat. QS. Al-Isra'[17]:36, QS. Muhammad[47]:19. Hlm. 171."
  },
  {
    "objectID": "paper/2024/fsr4/index.html#bagian-2-tak-semudah-itu-mengartikan-ilmu",
    "href": "paper/2024/fsr4/index.html#bagian-2-tak-semudah-itu-mengartikan-ilmu",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "Bagian 2: Tak Semudah Itu Mengartikan Ilmu",
    "text": "Bagian 2: Tak Semudah Itu Mengartikan Ilmu\n\n\n\\(^1\\)I\n\nlmu haruslah mengandung kebenaran. Hlm. 12. \\(^2\\)Ilmu adalah sampainya makna ke dalam jiwa. Hlm. 13. \\(^3\\)Pemahaman yang salah akan menghasilkan tindakan yang salah. Hlm. 13. \\(^4\\)Tujuan buku ini ditulis. Hlm. 13. \\(^5\\)Al-Quran & Al-Hadis merupakan inspirasi utama bagi setiap muslim. Hlm. 14. \\(^6\\)Seputar pertanyaan mengenai ilmu yang perlu untuk didiskusikan. Hlm. 15. \\(^7\\)Timbulnya sikap meremehkan ilmu disebabkan kurangnya pemahaman mengenai hakikat ilmu. Hlm.15. \\(^8\\)Mencari nafkah memerlukan ilmu juga. Hlm 17. \\(^9\\)Islam tidak melarang seseorang menuntut ilmu untuk menjadi bekal dalam menjamin kelangsungan hidupnya. Hlm. 17.\n\n\\(^{10}\\)Ajarilah anak-anak mu untuk dapat hidup di masanya, karena mereka[dia] dipersiapkan hidup pada masanya bukan pada masamu.-Sayyidina Ali bin Abi Thalib ra. Hlm. 18.-\n\n\n\\(^{11}\\)Barangsiapa yang dikhendaki Allah (SWT.) kebaikan baginya, Dia memberikan pemahaman kepadanya dalam ilmu Agama.- Sabda Rasulullah SAW. Hlm. 19.-\n\n\\(^{12}\\)Jika mengikuti petunjuk Allah SWT, maka ia tidak akan sesat dan celaka. Jika berpaling dari peringatan, maka baginya penghidupan yang sempit. Dalil. QS. Thaaha[20]:123-124. Hlm. 19."
  },
  {
    "objectID": "paper/2024/fsr4/index.html#bagian-3-ilmu-dan-kehidupan",
    "href": "paper/2024/fsr4/index.html#bagian-3-ilmu-dan-kehidupan",
    "title": "Ikhtisar Buku \"Inilah! Wasiat Nabi bagi Para Penuntut Ilmu\" karyanya Dr.¬†Wendi Zarman",
    "section": "Bagian 3: Ilmu dan Kehidupan",
    "text": "Bagian 3: Ilmu dan Kehidupan\n\n\n\\(^1\\)B\n\nudaya ilmu merupakan unsur inti pembentukan karakter setiap peradaban. Hlm. 23. \\(^2\\)Filsafat adalah cinta kebijaksanaan. Hlm. 26. \\(^3\\)Ajaran Hedonisme adalah ajaran yang mengajarkan kepuasan atau kesenangan manusia merupakan nilai kebaikan yang tertinggi. Hlm 26. \\(^4\\)Paham Humanisme adalah paham yang mendahulukan akal pikiran manusia dan mengesampingkan yang lain untuk menghakimi mana yang ‚Äòbenar‚Äô dan yang ‚Äòtidak benar‚Äô. Hlm. 27. \\(^5\\)Contoh para ilmuwan yang mencela dan menghujat agama:\n\nAgama itu candu.-Karl Marx-\n\n\nAgama adalah ilusi.-Sigmund Freud-\n\n\nTuhan sudah mati.-Friedrich Nietzche-\n\n\nSaya tidak tahu dimana letak peranan Tuhan.-Laplace-\n\nAguste Compte menyatakan bahwa pengetahuan lebih utama dibandingkan pertolongan Tuhan. Hlm. 29-30. \\(^6\\)Akhlak jeleknya JJ. Rosseau dan Jean Paul Sartre. Hlm. 32."
  }
]